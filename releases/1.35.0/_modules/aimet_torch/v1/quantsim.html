<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aimet_torch.v1.quantsim &mdash; AI Model Efficiency Toolkit Documentation: ver 1.35.0</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/style.css" />
      <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

    
    
    <a href="../../../user_guide/index.html" class="icon icon-home">
    AI Model Efficiency Toolkit
      <img src="../../../_static/brain_logo.png" class="logo" alt="Logo"/>
    </a>
      <div class="version">
        1.35.0
      </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html"> Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../install/index.html#quick-install">Quick Install</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/index.html#release-packages">Release Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/index.html#system-requirements">System Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../install/index.html#advanced-installation-instructions">Advanced Installation Instructions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../install/install_host.html">Install in Host Machine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#install-prerequisite-packages">Install prerequisite packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#install-gpu-packages">Install GPU packages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../install/install_host.html#install-gpu-packages-for-pytorch-2-1-or-pytorch-1-13-or-onnx-or-tensorflow">Install GPU packages for PyTorch 2.1 or PyTorch 1.13 or ONNX or TensorFlow</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#install-aimet-packages">Install AIMET packages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../install/install_host.html#from-pypi">From PyPI</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../install/install_host.html#from-release-package">From Release Package</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#install-common-debian-packages">Install common debian packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#install-tensorflow-gpu-debian-packages">Install tensorflow GPU debian packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#install-torch-gpu-debian-packages">Install torch GPU debian packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#install-onnx-gpu-debian-packages">Install ONNX GPU debian packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#replace-pillow-with-pillow-simd">Replace Pillow with Pillow-SIMD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#replace-onnxruntime-with-onnxruntime-gpu">Replace onnxruntime with onnxruntime-gpu</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#post-installation-steps">Post installation steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_host.html#environment-setup">Environment setup</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../install/install_docker.html">Install in Docker Container</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_docker.html#set-variant">Set variant</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_docker.html#use-prebuilt-docker-image">Use prebuilt docker image</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_docker.html#build-docker-image-locally">Build docker image locally</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_docker.html#start-docker-container">Start docker container</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_docker.html#install-aimet-packages">Install AIMET packages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../install/install_docker.html#from-pypi">From PyPI</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../install/install_docker.html#from-release-package">From Release Package</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../install/install_docker.html#environment-setup">Environment setup</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide/model_quantization.html"> Quantization User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_quantization.html#use-cases">Use cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_quantization.html#aimet-quantization-features">AIMET quantization features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/quantization_sim.html"> Quantization Simulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_sim.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_sim.html#quantsim-workflow">QuantSim workflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_sim.html#simulating-quantization-noise">Simulating quantization noise</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_sim.html#determining-quantization-parameters-encodings">Determining quantization parameters (encodings)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_sim.html#quantization-schemes">Quantization schemes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_sim.html#configuring-quantization-simulation-operations">Configuring quantization simulation operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_sim.html#quantization-simulation-apis">Quantization Simulation APIs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/quantization_aware_training.html"> Quantization-Aware Training (QAT)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_aware_training.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_aware_training.html#qat-workflow">QAT workflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_aware_training.html#qat-modes">QAT modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quantization_aware_training.html#recommendations-for-quantization-aware-training">Recommendations for quantization-aware training</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/model_quantization.html#post-training-quantization"><span class="hideitem">Post-Training Quantization</span></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/auto_quant.html">AutoQuant</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/auto_quant.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/auto_quant.html#workflow">Workflow</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/auto_quant.html#autoquant-api">AutoQuant API</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/adaround.html">Adaptive Rounding (AdaRound)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/adaround.html#adaround-use-cases">AdaRound use cases</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/adaround.html#adaround-hyper-parameters-guidelines">AdaRound hyper parameters guidelines</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/adaround.html#adaround-api">AdaRound API</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html">Cross-Layer Equalization</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#user-flow">User Flow</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#cross-layer-equalization-api">Cross-Layer Equalization API</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#faqs">FAQs</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/bn_reestimation.html">BN Re-estimation</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/bn_reestimation.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/bn_reestimation.html#workflow">Workflow</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/bn_reestimation.html#bn-re-estimation-api">BN Re-estimation API</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html">Bias Correction [Deprecated]</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#user-flow">User Flow</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#cross-layer-equalization-api">Cross-Layer Equalization API</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#faqs">FAQs</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/post_training_quant_techniques.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/model_quantization.html#debugging-and-analysis-tools"><span class="hideitem">Debugging and Analysis Tools</span></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/quant_analyzer.html">QuantAnalyzer</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/quant_analyzer.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/quant_analyzer.html#requirements">Requirements</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/quant_analyzer.html#detailed-analysis-descriptions">Detailed analysis descriptions</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/quant_analyzer.html#quantanalyzer-api">QuantAnalyzer API</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/visualization_quant.html">Visualizations</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/visualization_quant.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/visualization_quant.html#quantization">Quantization</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../user_guide/visualization_quant.html#pytorch">PyTorch</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../user_guide/visualization_quant.html#tensorflow">TensorFlow</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_quantization.html#aimet-quantization-workflow">AIMET quantization workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/model_quantization.html#pytorch"><span class="hideitem">PyTorch</span></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_quantization.html#debugging">Debugging</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/quantization_feature_guidebook.html">Quantization Diagnostics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide/model_compression.html"> Compression User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_compression.html#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/compression_feature_guidebook.html">Compression Guidebook</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_compression.html#use-case">Use Case</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_compression.html#compression-ratio-selection">Compression ratio selection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/greedy_compression_ratio_selection.html">Greedy compression ratio selection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/greedy_compression_ratio_selection.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/greedy_compression_ratio_selection.html#how-it-works">How it works</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/greedy_compression_ratio_selection.html#per-layer-exploration">Per-layer exploration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/greedy_compression_ratio_selection.html#compression-ratio-selection">Compression ratio selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/visualization_compression.html">Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/visualization_compression.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/visualization_compression.html#design">Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/visualization_compression.html#compression">Compression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/visualization_compression.html#starting-a-bokeh-server-session">Starting a Bokeh server session</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/visualization_compression.html#visualizing-compression-ratios">Visualizing compression ratios</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_compression.html#model-compression">Model compression</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/weight_svd.html">Weight SVD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/spatial_svd.html">Spatial SVD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/channel_pruning.html">Channel pruning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/channel_pruning.html#procedure">Procedure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/channel_pruning.html#channel-selection">Channel selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/channel_pruning.html#winnowing">Winnowing</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../user_guide/winnowing.html">Winnowing</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../user_guide/winnowing.html#overview">Overview</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../user_guide/winnowing.html#winnowing-overview">Winnowing overview</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../user_guide/winnowing.html#how-winnowing-works">How winnowing works</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../user_guide/channel_pruning.html#weight-reconstruction">Weight reconstruction</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_compression.html#optional-techniques">Optional techniques</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/model_compression.html#rank-rounding">Rank Rounding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/model_compression.html#per-layer-fine-tuning">Per-layer fine-tuning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_compression.html#faqs">FAQs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/model_compression.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_docs/index.html"> API Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api_docs/torch.html">AIMET APIs for PyTorch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/torch_quantization.html">PyTorch Model Quantization API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_quantization.html#aimet-torch">aimet_torch</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_quantization.html#api-reference">API Reference</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_model_guidelines.html"> Model Guidelines</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_architecture_checker.html"> Architecture Checker API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_architecture_checker.html#aimet_torch.arch_checker.arch_checker.ArchChecker.check_model_arch"><code class="docutils literal notranslate"><span class="pre">check_model_arch()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_model_preparer.html"> Model Preparer API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_model_preparer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_model_preparer.html#aimet_torch.model_preparer.prepare_model"><code class="docutils literal notranslate"><span class="pre">prepare_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_model_preparer.html#code-examples">Code Examples</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_model_preparer.html#limitations-of-torch-fx-symbolic-trace-api">Limitations of torch.fx symbolic trace API</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_model_validator.html"> Model Validator API</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html"> Quant Analyzer API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_torch.v1.quant_analyzer.QuantAnalyzer"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_torch.v1.quant_analyzer.QuantAnalyzer.enable_per_layer_mse_loss"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.enable_per_layer_mse_loss()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_torch.v1.quant_analyzer.QuantAnalyzer.analyze"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.analyze()</span></code></a></li>
</ul>
</li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_common.utils.CallbackFunc"><code class="docutils literal notranslate"><span class="pre">CallbackFunc</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#run-specific-utility">Run specific utility</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_torch.v1.quant_analyzer.QuantAnalyzer.check_model_sensitivity_to_quantization"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.check_model_sensitivity_to_quantization()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_torch.v1.quant_analyzer.QuantAnalyzer.perform_per_layer_analysis_by_enabling_quant_wrappers"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.perform_per_layer_analysis_by_enabling_quant_wrappers()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_torch.v1.quant_analyzer.QuantAnalyzer.perform_per_layer_analysis_by_disabling_quant_wrappers"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.perform_per_layer_analysis_by_disabling_quant_wrappers()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_torch.v1.quant_analyzer.QuantAnalyzer.export_per_layer_encoding_min_max_range"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.export_per_layer_encoding_min_max_range()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_torch.v1.quant_analyzer.QuantAnalyzer.export_per_layer_stats_histogram"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.export_per_layer_stats_histogram()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#aimet_torch.v1.quant_analyzer.QuantAnalyzer.export_per_layer_mse_loss"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.export_per_layer_mse_loss()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quant_analyzer.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_quantsim.html"> Quantization Simulation API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#guidelines">Guidelines</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_torch.v1.quantsim.QuantizationSimModel"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_torch.v1.quantsim.QuantizationSimModel.compute_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.compute_encodings()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_torch.v1.quantsim.QuantizationSimModel.export"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.export()</span></code></a></li>
</ul>
</li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_torch.v1.quantsim.save_checkpoint"><code class="docutils literal notranslate"><span class="pre">quantsim.save_checkpoint()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_torch.v1.quantsim.load_checkpoint"><code class="docutils literal notranslate"><span class="pre">quantsim.load_checkpoint()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme"><code class="docutils literal notranslate"><span class="pre">QuantScheme</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.post_training_percentile"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_percentile</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.post_training_tf"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.post_training_tf_enhanced"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf_enhanced</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_enhanced_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_enhanced_init</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_init</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_quantsim.html#code-example-quantization-aware-training-qat">Code Example - Quantization Aware Training (QAT)</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_adaround.html"> Adaptive Rounding API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_adaround.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_adaround.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_adaround.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_adaround.html#aimet_torch.v1.adaround.adaround_weight.Adaround.apply_adaround"><code class="docutils literal notranslate"><span class="pre">apply_adaround()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_adaround.html#adaround-parameters">Adaround Parameters</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_adaround.html#aimet_torch.v1.adaround.adaround_weight.AdaroundParameters"><code class="docutils literal notranslate"><span class="pre">AdaroundParameters</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_adaround.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme"><code class="docutils literal notranslate"><span class="pre">QuantScheme</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.post_training_percentile"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_percentile</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.post_training_tf"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.post_training_tf_enhanced"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf_enhanced</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_enhanced_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_enhanced_init</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_init</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_adaround.html#code-example-adaptive-rounding-adaround">Code Example - Adaptive Rounding (AdaRound)</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_cross_layer_equalization.html"> Cross-Layer Equalization API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_cross_layer_equalization.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_cross_layer_equalization.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_cross_layer_equalization.html#introduction">Introduction</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_cross_layer_equalization.html#cross-layer-equalization-api">Cross Layer Equalization API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_cross_layer_equalization.html#aimet_torch.cross_layer_equalization.equalize_model"><code class="docutils literal notranslate"><span class="pre">equalize_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_cross_layer_equalization.html#code-example">Code Example</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_cross_layer_equalization.html#primitive-apis">Primitive APIs</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html">Primitive APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#introduction">Introduction</a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#clssetinfo-definition">ClsSetInfo Definition</a><ul>
<li class="toctree-l10"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.ClsSetInfo"><code class="docutils literal notranslate"><span class="pre">ClsSetInfo</span></code></a></li>
</ul>
</li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#higher-level-apis-for-cross-layer-equalization">Higher Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l10"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#aimet_torch.batch_norm_fold.fold_all_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms()</span></code></a></li>
<li class="toctree-l10"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.CrossLayerScaling.scale_model"><code class="docutils literal notranslate"><span class="pre">scale_model()</span></code></a></li>
<li class="toctree-l10"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.HighBiasFold.bias_fold"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#code-examples-for-higher-level-apis">Code Examples for Higher Level APIs</a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#lower-level-apis-for-cross-layer-equalization">Lower Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l10"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#aimet_torch.batch_norm_fold.fold_given_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_given_batch_norms()</span></code></a></li>
<li class="toctree-l10"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.CrossLayerScaling.scale_cls_sets"><code class="docutils literal notranslate"><span class="pre">scale_cls_sets()</span></code></a></li>
<li class="toctree-l10"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#id0"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_primitive_apis_cle.html#code-examples-for-lower-level-apis">Code Examples for Lower Level APIs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html"> Bias Correction API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#bias-correction-api">Bias Correction API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#aimet_torch.bias_correction.correct_bias"><code class="docutils literal notranslate"><span class="pre">correct_bias()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#convbninfotype">ConvBnInfoType</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#aimet_common.bias_correction.ConvBnInfoType"><code class="docutils literal notranslate"><span class="pre">ConvBnInfoType</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#activationtype">ActivationType</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType"><code class="docutils literal notranslate"><span class="pre">ActivationType</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType.no_activation"><code class="docutils literal notranslate"><span class="pre">ActivationType.no_activation</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType.relu"><code class="docutils literal notranslate"><span class="pre">ActivationType.relu</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType.relu6"><code class="docutils literal notranslate"><span class="pre">ActivationType.relu6</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#quantization-params">Quantization Params</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#aimet_torch.v1.quantsim.QuantParams"><code class="docutils literal notranslate"><span class="pre">QuantParams</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#code-example-1-empirical-bias-correction">Code Example #1 Empirical Bias Correction</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_bias_correction.html#code-example-2-analytical-empirical-bias-correction">Code Example #2 Analytical + Empirical Bias correction</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_auto_quant.html"> AutoQuant API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_auto_quant.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_auto_quant.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_auto_quant.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_auto_quant.html#aimet_torch.v1.auto_quant.AutoQuant"><code class="docutils literal notranslate"><span class="pre">AutoQuant</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_auto_quant.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_batchnorm_re_estimation.html"> BN Re-estimation APIs</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_batchnorm_re_estimation.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_batchnorm_re_estimation.html#introduction">Introduction</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_batchnorm_re_estimation.html#top-level-apis">Top-level APIs</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_batchnorm_re_estimation.html#aimet_torch.bn_reestimation.reestimate_bn_stats"><code class="docutils literal notranslate"><span class="pre">reestimate_bn_stats()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_batchnorm_re_estimation.html#aimet_torch.batch_norm_fold.fold_all_batch_norms_to_scale"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms_to_scale()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_batchnorm_re_estimation.html#code-example-bn-reestimation">Code Example - BN-Reestimation</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_multi_gpu.html"> Multi-GPU guidelines</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html"> PEFT LoRA APIs</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#user-flow">User flow</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.AdapterMetaData"><code class="docutils literal notranslate"><span class="pre">AdapterMetaData</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.replace_lora_layers_with_quantizable_layers"><code class="docutils literal notranslate"><span class="pre">peft.replace_lora_layers_with_quantizable_layers()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.track_lora_meta_data"><code class="docutils literal notranslate"><span class="pre">peft.track_lora_meta_data()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.disable_lora_adapters"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.disable_lora_adapters()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.enable_adapter_and_load_weights"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.enable_adapter_and_load_weights()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.export_adapter_weights"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.export_adapter_weights()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.freeze_base_model"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.freeze_base_model()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.freeze_base_model_activation_quantizers"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.freeze_base_model_activation_quantizers()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.freeze_base_model_param_quantizers"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.freeze_base_model_param_quantizers()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.get_fp_lora_layer"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.get_fp_lora_layer()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.get_quantized_lora_layer"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.get_quantized_lora_layer()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.quantize_lora_scale_with_fixed_range"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.quantize_lora_scale_with_fixed_range()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/torch_peft_lora.html#aimet_torch.peft.PeftQuantUtils.set_bitwidth_for_lora_adapters"><code class="docutils literal notranslate"><span class="pre">PeftQuantUtils.set_bitwidth_for_lora_adapters()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_quantization.html#aimet-torch-v2">aimet_torch.v2</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_quantization.html#what-s-new">Whatâ€™s New</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_quantization.html#backwards-compatibility">Backwards Compatibility</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_quantization.html#id1">API Reference</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../torch_docs/quantized_modules.html">Quantized Modules</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#aimet_torch.v2.nn.QuantizationMixin"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#aimet_torch.v2.nn.QuantizationMixin.input_quantizers"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.input_quantizers</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#aimet_torch.v2.nn.QuantizationMixin.output_quantizers"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.output_quantizers</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#aimet_torch.v2.nn.QuantizationMixin.param_quantizers"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.param_quantizers</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#aimet_torch.v2.nn.QuantizationMixin.__quant_init__"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.__quant_init__()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#aimet_torch.v2.nn.QuantizationMixin.compute_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.compute_encodings()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#aimet_torch.v2.nn.QuantizationMixin.forward"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.forward()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#configuration">Configuration</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#computing-encodings">Computing Encodings</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/quantized_modules.html#quantized-module-classes">Quantized Module Classes</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../torch_docs/quantizer.html">Quantizers</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/quantizer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizerBase"><code class="docutils literal notranslate"><span class="pre">QuantizerBase</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizerBase.allow_overwrite"><code class="docutils literal notranslate"><span class="pre">QuantizerBase.allow_overwrite()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizerBase.compute_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizerBase.compute_encodings()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizerBase.get_encoding"><code class="docutils literal notranslate"><span class="pre">QuantizerBase.get_encoding()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizerBase.get_legacy_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizerBase.get_legacy_encodings()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizerBase.is_initialized"><code class="docutils literal notranslate"><span class="pre">QuantizerBase.is_initialized()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizerBase.register_quantization_parameter"><code class="docutils literal notranslate"><span class="pre">QuantizerBase.register_quantization_parameter()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizerBase.set_legacy_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizerBase.set_legacy_encodings()</span></code></a></li>
</ul>
</li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizeDequantize"><code class="docutils literal notranslate"><span class="pre">QuantizeDequantize</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.QuantizeDequantize.forward"><code class="docutils literal notranslate"><span class="pre">QuantizeDequantize.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.Quantize"><code class="docutils literal notranslate"><span class="pre">Quantize</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../torch_docs/quantizer.html#aimet_torch.v2.quantization.affine.quantizer.Quantize.forward"><code class="docutils literal notranslate"><span class="pre">Quantize.forward()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html">QuantizationMixin</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin</span></code></a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.input_quantizers"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.input_quantizers</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.output_quantizers"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.output_quantizers</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.param_quantizers"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.param_quantizers</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.forward"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.forward()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.__quant_init__"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.__quant_init__()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.set_kernel"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.set_kernel()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.set_default_kernel"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.set_default_kernel()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.compute_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.compute_encodings()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.from_module"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.from_module()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.get_default_kernel"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.get_default_kernel()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.get_kernel"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.get_kernel()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/nn.quantization_mixin.html#aimet_torch.v2.nn.QuantizationMixin.implements"><code class="docutils literal notranslate"><span class="pre">QuantizationMixin.implements()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../torch_docs/api/quantization/affine/index.html">quantization.affine</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/api/quantization/affine/index.html#classes">Classes</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/quantization/affine/index.html#aimet_torch.v2.quantization.affine.Quantize"><code class="docutils literal notranslate"><span class="pre">Quantize</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/quantization/affine/index.html#aimet_torch.v2.quantization.affine.QuantizeDequantize"><code class="docutils literal notranslate"><span class="pre">QuantizeDequantize</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/api/quantization/affine/index.html#functions">Functions</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/quantization/affine/index.html#aimet_torch.v2.quantization.affine.quantize"><code class="docutils literal notranslate"><span class="pre">quantize()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/quantization/affine/index.html#aimet_torch.v2.quantization.affine.quantize_dequantize"><code class="docutils literal notranslate"><span class="pre">quantize_dequantize()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/quantization/affine/index.html#aimet_torch.v2.quantization.affine.dequantize"><code class="docutils literal notranslate"><span class="pre">dequantize()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../torch_docs/api/quantization/float/index.html">quantization.float</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/api/quantization/float/index.html#classes">Classes</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/quantization/float/index.html#aimet_torch.v2.quantization.float.FloatQuantizeDequantize"><code class="docutils literal notranslate"><span class="pre">FloatQuantizeDequantize</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/api/quantization/float/index.html#aimet_torch.v2.quantization.float.QuantizeDequantize"><code class="docutils literal notranslate"><span class="pre">QuantizeDequantize</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../torch_docs/encoding_analyzer.html">Encoding Analyzers</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/encoding_analyzer.html#aimet_torch.v2.quantization.encoding_analyzer.EncodingAnalyzer"><code class="docutils literal notranslate"><span class="pre">EncodingAnalyzer</span></code></a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/encoding_analyzer.html#aimet_torch.v2.quantization.encoding_analyzer.EncodingAnalyzer.compute_encodings"><code class="docutils literal notranslate"><span class="pre">EncodingAnalyzer.compute_encodings()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/encoding_analyzer.html#aimet_torch.v2.quantization.encoding_analyzer.EncodingAnalyzer.reset_stats"><code class="docutils literal notranslate"><span class="pre">EncodingAnalyzer.reset_stats()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/encoding_analyzer.html#aimet_torch.v2.quantization.encoding_analyzer.EncodingAnalyzer.update_stats"><code class="docutils literal notranslate"><span class="pre">EncodingAnalyzer.update_stats()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/encoding_analyzer.html#variants">Variants</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/encoding_analyzer.html#aimet_torch.v2.quantization.encoding_analyzer.MinMaxEncodingAnalyzer"><code class="docutils literal notranslate"><span class="pre">MinMaxEncodingAnalyzer</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/encoding_analyzer.html#aimet_torch.v2.quantization.encoding_analyzer.SqnrEncodingAnalyzer"><code class="docutils literal notranslate"><span class="pre">SqnrEncodingAnalyzer</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../torch_docs/encoding_analyzer.html#aimet_torch.v2.quantization.encoding_analyzer.PercentileEncodingAnalyzer"><code class="docutils literal notranslate"><span class="pre">PercentileEncodingAnalyzer</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../../torch_docs/api/visualization_tools.html">Visualization Tools</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../torch_docs/api/visualization_tools.html#aimet_torch.v2.visualization_tools.visualize_stats"><code class="docutils literal notranslate"><span class="pre">visualize_stats()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/torch_compress.html">PyTorch Model Compression API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_compress.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_compress.html#top-level-api-for-compression">Top-level API for Compression</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.compress.ModelCompressor"><code class="docutils literal notranslate"><span class="pre">ModelCompressor</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.compress.ModelCompressor.compress_model"><code class="docutils literal notranslate"><span class="pre">ModelCompressor.compress_model()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_compress.html#greedy-selection-parameters">Greedy Selection Parameters</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_common.defs.GreedySelectionParameters"><code class="docutils literal notranslate"><span class="pre">GreedySelectionParameters</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_compress.html#spatial-svd-configuration">Spatial SVD Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.Mode"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_compress.html#weight-svd-configuration">Weight SVD Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.Mode"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_compress.html#channel-pruning-configuration">Channel Pruning Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.Mode"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_compress.html#configuration-definitions">Configuration Definitions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_compress.html#aimet_torch.defs.ModuleCompRatioPair"><code class="docutils literal notranslate"><span class="pre">ModuleCompRatioPair</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_compress.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/torch_visualization_compression.html">PyTorch Model Visualization API for Compression</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_visualization_compression.html#top-level-api-compression">Top-level API Compression</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_visualization_compression.html#aimet_torch.visualize_serialized_data.VisualizeCompression"><code class="docutils literal notranslate"><span class="pre">VisualizeCompression</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_visualization_compression.html#aimet_torch.visualize_serialized_data.VisualizeCompression.display_eval_scores"><code class="docutils literal notranslate"><span class="pre">VisualizeCompression.display_eval_scores()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_visualization_compression.html#aimet_torch.visualize_serialized_data.VisualizeCompression.display_comp_ratio_plot"><code class="docutils literal notranslate"><span class="pre">VisualizeCompression.display_comp_ratio_plot()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_visualization_compression.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/torch_visualization_quantization.html">PyTorch Model Visualization API for Quantization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_visualization_quantization.html#top-level-api-quantization">Top-level API Quantization</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_visualization_quantization.html#aimet_torch.visualize_model.visualize_relative_weight_ranges_to_identify_problematic_layers"><code class="docutils literal notranslate"><span class="pre">visualize_relative_weight_ranges_to_identify_problematic_layers()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_visualization_quantization.html#aimet_torch.visualize_model.visualize_weight_ranges"><code class="docutils literal notranslate"><span class="pre">visualize_weight_ranges()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_visualization_quantization.html#aimet_torch.visualize_model.visualize_changes_after_optimization"><code class="docutils literal notranslate"><span class="pre">visualize_changes_after_optimization()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_visualization_quantization.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html">PyTorch Debug API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.LayerOutputUtil"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.LayerOutputUtil.generate_layer_outputs"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil.generate_layer_outputs()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.NamingScheme"><code class="docutils literal notranslate"><span class="pre">NamingScheme</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.NamingScheme.ONNX"><code class="docutils literal notranslate"><span class="pre">NamingScheme.ONNX</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.NamingScheme.PYTORCH"><code class="docutils literal notranslate"><span class="pre">NamingScheme.PYTORCH</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.NamingScheme.TORCHSCRIPT"><code class="docutils literal notranslate"><span class="pre">NamingScheme.TORCHSCRIPT</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/torch_layer_output_generation.html#code-example">Code Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_docs/keras.html">AIMET APIs for TensorFlow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/keras_quantization.html">TensorFlow Model Quantization API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_model_guidelines.html"> Model Guidelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_model_preparer.html"> Model Preparer API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_model_preparer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_model_preparer.html#aimet_tensorflow.keras.model_preparer.prepare_model"><code class="docutils literal notranslate"><span class="pre">prepare_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_model_preparer.html#code-examples">Code Examples</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_model_preparer.html#limitations">Limitations</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_quant_analyzer.html"> Quant Analyzer API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_quant_analyzer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_quant_analyzer.html#aimet_tensorflow.keras.quant_analyzer.QuantAnalyzer"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_quant_analyzer.html#aimet_tensorflow.keras.quant_analyzer.QuantAnalyzer.analyze"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.analyze()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_quant_analyzer.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_quantsim.html"> Quantization Simulation API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_quantsim.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_quantsim.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_quantsim.html#aimet_tensorflow.keras.quantsim.QuantizationSimModel"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_quantsim.html#aimet_tensorflow.keras.quantsim.QuantizationSimModel.compute_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.compute_encodings()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_quantsim.html#aimet_tensorflow.keras.quantsim.QuantizationSimModel.export"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.export()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_quantsim.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_adaround.html"> Adaptive Rounding API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_adaround.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_adaround.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_adaround.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_adaround.html#aimet_tensorflow.keras.adaround_weight.Adaround.apply_adaround"><code class="docutils literal notranslate"><span class="pre">apply_adaround()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_adaround.html#adaround-parameters">Adaround Parameters</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_adaround.html#aimet_tensorflow.keras.adaround_weight.AdaroundParameters"><code class="docutils literal notranslate"><span class="pre">AdaroundParameters</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_adaround.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme"><code class="docutils literal notranslate"><span class="pre">QuantScheme</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.post_training_percentile"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_percentile</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.post_training_tf"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.post_training_tf_enhanced"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf_enhanced</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_enhanced_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_enhanced_init</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_init</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_adaround.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_cross_layer_equalization.html"> Cross-Layer Equalization API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_cross_layer_equalization.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_cross_layer_equalization.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_cross_layer_equalization.html#introduction">Introduction</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_cross_layer_equalization.html#cross-layer-equalization-api">Cross Layer Equalization API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_cross_layer_equalization.html#aimet_tensorflow.keras.cross_layer_equalization.equalize_model"><code class="docutils literal notranslate"><span class="pre">equalize_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_cross_layer_equalization.html#code-example">Code Example</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_cross_layer_equalization.html#primitive-apis">Primitive APIs</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html">Primitive APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#introduction">Introduction</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#higher-level-apis-for-cross-layer-equalization">Higher Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.batch_norm_fold.fold_all_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.CrossLayerScaling.scale_model"><code class="docutils literal notranslate"><span class="pre">scale_model()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.HighBiasFold.bias_fold"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#code-examples-for-higher-level-apis">Code Examples for Higher Level APIs</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#lower-level-apis-for-cross-layer-equalization">Lower Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.batch_norm_fold.fold_given_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_given_batch_norms()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.CrossLayerScaling.scale_cls_sets"><code class="docutils literal notranslate"><span class="pre">scale_cls_sets()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#id0"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#custom-datatype-used">Custom Datatype used</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.ClsSetInfo"><code class="docutils literal notranslate"><span class="pre">ClsSetInfo</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.ClsSetInfo.ClsSetLayerPairInfo"><code class="docutils literal notranslate"><span class="pre">ClsSetInfo.ClsSetLayerPairInfo</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#code-example-for-lower-level-apis">Code Example for Lower level APIs</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_primitive_apis_cle.html#example-helper-methods-to-perform-cle-in-manual-mode">Example helper methods to perform CLE in manual mode</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_batchnorm_re_estimation.html"> BN Re-estimation APIs</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_batchnorm_re_estimation.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_batchnorm_re_estimation.html#introduction">Introduction</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_batchnorm_re_estimation.html#top-level-apis">Top-level APIs</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_batchnorm_re_estimation.html#aimet_tensorflow.keras.bn_reestimation.reestimate_bn_stats"><code class="docutils literal notranslate"><span class="pre">reestimate_bn_stats()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_batchnorm_re_estimation.html#aimet_tensorflow.keras.batch_norm_fold.fold_all_batch_norms_to_scale"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms_to_scale()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_batchnorm_re_estimation.html#code-example">Code Example</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_batchnorm_re_estimation.html#limitations">Limitations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/keras_layer_output_generation.html">TensorFlow Debug API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_layer_output_generation.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_layer_output_generation.html#aimet_tensorflow.keras.layer_output_utils.LayerOutputUtil"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_layer_output_generation.html#aimet_tensorflow.keras.layer_output_utils.LayerOutputUtil.generate_layer_outputs"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil.generate_layer_outputs()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_layer_output_generation.html#code-example">Code Example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/keras_compression.html">TensorFlow Model Compression API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_compression.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_compression.html#top-level-api-for-compression">Top-level API for Compression</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_tensorflow.keras.compress.ModelCompressor"><code class="docutils literal notranslate"><span class="pre">ModelCompressor</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_tensorflow.keras.compress.ModelCompressor.compress_model"><code class="docutils literal notranslate"><span class="pre">ModelCompressor.compress_model()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_compression.html#greedy-selection-parameters">Greedy Selection Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_compression.html#spatial-svd-configuration">Spatial SVD Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_tensorflow.keras.defs.SpatialSvdParameters"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_tensorflow.keras.defs.SpatialSvdParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_tensorflow.keras.defs.SpatialSvdParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_tensorflow.keras.defs.SpatialSvdParameters.Mode"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_tensorflow.keras.defs.SpatialSvdParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_tensorflow.keras.defs.SpatialSvdParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_compression.html#configuration-definitions">Configuration Definitions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_common.defs.CostMetric"><code class="docutils literal notranslate"><span class="pre">CostMetric</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_common.defs.CostMetric.mac"><code class="docutils literal notranslate"><span class="pre">CostMetric.mac</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_common.defs.CostMetric.memory"><code class="docutils literal notranslate"><span class="pre">CostMetric.memory</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_common.defs.CompressionScheme"><code class="docutils literal notranslate"><span class="pre">CompressionScheme</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_common.defs.CompressionScheme.channel_pruning"><code class="docutils literal notranslate"><span class="pre">CompressionScheme.channel_pruning</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_common.defs.CompressionScheme.spatial_svd"><code class="docutils literal notranslate"><span class="pre">CompressionScheme.spatial_svd</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_common.defs.CompressionScheme.weight_svd"><code class="docutils literal notranslate"><span class="pre">CompressionScheme.weight_svd</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/keras_compression.html#aimet_tensorflow.keras.defs.ModuleCompRatioPair"><code class="docutils literal notranslate"><span class="pre">ModuleCompRatioPair</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/keras_compression.html#code-examples">Code Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_docs/onnx.html">AIMET APIs for ONNX</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/onnx_quantization.html">ONNX Model Quantization API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/onnx_quantsim.html"> Quantization Simulation API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_quantsim.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_quantsim.html#aimet_onnx.quantsim.QuantizationSimModel"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/onnx_quantsim.html#aimet_onnx.quantsim.QuantizationSimModel.compute_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.compute_encodings()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/onnx_quantsim.html#aimet_onnx.quantsim.QuantizationSimModel.export"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.export()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_quantsim.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/onnx_cross_layer_equalization.html"> Cross-Layer Equalization API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_cross_layer_equalization.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_cross_layer_equalization.html#introduction">Introduction</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_cross_layer_equalization.html#cross-layer-equalization-api">Cross Layer Equalization API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_cross_layer_equalization.html#aimet_onnx.cross_layer_equalization.equalize_model"><code class="docutils literal notranslate"><span class="pre">equalize_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_cross_layer_equalization.html#code-example">Code Example</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/onnx_adaround.html"> Adaptive Rounding API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_adaround.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_adaround.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_adaround.html#aimet_onnx.adaround.adaround_weight.Adaround.apply_adaround"><code class="docutils literal notranslate"><span class="pre">apply_adaround()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_adaround.html#adaround-parameters">Adaround Parameters</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_adaround.html#aimet_onnx.adaround.adaround_weight.AdaroundParameters"><code class="docutils literal notranslate"><span class="pre">AdaroundParameters</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_adaround.html#code-example-adaptive-rounding-adaround">Code Example - Adaptive Rounding (AdaRound)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html"> AutoQuant API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html#aimet_onnx.auto_quant_v2.AutoQuant"><code class="docutils literal notranslate"><span class="pre">AutoQuant</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html#aimet_onnx.auto_quant_v2.AutoQuant.run_inference"><code class="docutils literal notranslate"><span class="pre">AutoQuant.run_inference()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html#aimet_onnx.auto_quant_v2.AutoQuant.optimize"><code class="docutils literal notranslate"><span class="pre">AutoQuant.optimize()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html#aimet_onnx.auto_quant_v2.AutoQuant.set_adaround_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_adaround_params()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html#aimet_onnx.auto_quant_v2.AutoQuant.get_quant_scheme_candidates"><code class="docutils literal notranslate"><span class="pre">AutoQuant.get_quant_scheme_candidates()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html#aimet_onnx.auto_quant_v2.AutoQuant.set_quant_scheme_candidates"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_quant_scheme_candidates()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_auto_quant.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html"> QuantAnalyzer API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer.enable_per_layer_mse_loss"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.enable_per_layer_mse_loss()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer.analyze"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.analyze()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#run-specific-utility">Run specific utility</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer.create_quantsim_and_encodings"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.create_quantsim_and_encodings()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer.check_model_sensitivity_to_quantization"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.check_model_sensitivity_to_quantization()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer.perform_per_layer_analysis_by_enabling_quantizers"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.perform_per_layer_analysis_by_enabling_quantizers()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer.perform_per_layer_analysis_by_disabling_quantizers"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.perform_per_layer_analysis_by_disabling_quantizers()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer.export_per_layer_encoding_min_max_range"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.export_per_layer_encoding_min_max_range()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer.export_per_layer_stats_histogram"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.export_per_layer_stats_histogram()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#aimet_onnx.quant_analyzer.QuantAnalyzer.export_per_layer_mse_loss"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.export_per_layer_mse_loss()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_quant_analyzer.html#code-examples">Code Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_docs/onnx_layer_output_generation.html">ONNX Debug API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/onnx_layer_output_generation.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../api_docs/onnx_layer_output_generation.html#aimet_onnx.layer_output_utils.LayerOutputUtil"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../../api_docs/onnx_layer_output_generation.html#aimet_onnx.layer_output_utils.LayerOutputUtil.generate_layer_outputs"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil.generate_layer_outputs()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_docs/onnx_layer_output_generation.html#code-example">Code Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_docs/index.html#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide/examples.html"> Examples Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/examples.html#browse-the-notebooks">Browse the notebooks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../user_guide/examples.html#running-the-notebooks">Running the notebooks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/examples.html#run-the-notebook-server">1. Run the notebook server</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/examples.html#download-the-example-notebooks-and-related-code">2. Download the example notebooks and related code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../user_guide/examples.html#run-the-notebooks">3. Run the notebooks</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../user_guide/index.html">AI Model Efficiency Toolkit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../user_guide/index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">aimet_torch.v1.quantsim</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aimet_torch.v1.quantsim</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- mode: python -*-</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#  @@-COPYRIGHT-START-@@</span>
<span class="c1">#</span>
<span class="c1">#  Copyright (c) 2019-2024, Qualcomm Innovation Center, Inc. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1">#  Redistribution and use in source and binary forms, with or without</span>
<span class="c1">#  modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1">#  1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#     this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#  2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#     this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#     and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1">#  3. Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1">#     may be used to endorse or promote products derived from this software</span>
<span class="c1">#     without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1">#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1">#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1">#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1">#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1">#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1">#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1">#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1">#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1">#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1">#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1">#  POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1">#  SPDX-License-Identifier: BSD-3-Clause</span>
<span class="c1">#</span>
<span class="c1">#  @@-COPYRIGHT-END-@@</span>
<span class="c1"># =============================================================================</span>

<span class="sd">&quot;&quot;&quot; Implementation for simulating models running on Quantized hardware &quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=too-many-lines</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">runtime_checkable</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">,</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">onnx</span>
<span class="kn">from</span> <span class="nn">packaging</span> <span class="kn">import</span> <span class="n">version</span>  <span class="c1"># pylint: disable=wrong-import-order</span>
<span class="kn">from</span> <span class="nn">safetensors.numpy</span> <span class="kn">import</span> <span class="n">save_file</span> <span class="k">as</span> <span class="n">save_safetensor_file</span>

<span class="kn">import</span> <span class="nn">aimet_common.libpymo</span> <span class="k">as</span> <span class="nn">libpymo</span>
<span class="kn">from</span> <span class="nn">aimet_common</span> <span class="kn">import</span> <span class="n">quantsim</span>

<span class="kn">from</span> <span class="nn">aimet_common.connected_graph.connectedgraph_utils</span> <span class="kn">import</span> <span class="n">CG_SPLIT</span>
<span class="kn">from</span> <span class="nn">aimet_common.utils</span> <span class="kn">import</span> <span class="n">AimetLogger</span><span class="p">,</span> <span class="n">save_json_yaml</span><span class="p">,</span> <span class="n">log_with_error_and_assert_if_false</span>
<span class="kn">from</span> <span class="nn">aimet_common.defs</span> <span class="kn">import</span> <span class="n">QuantScheme</span><span class="p">,</span> <span class="n">QuantizationDataType</span><span class="p">,</span> <span class="n">SupportedKernelsAction</span><span class="p">,</span> <span class="n">QuantDtypeBwInfo</span>
<span class="kn">from</span> <span class="nn">aimet_common.quantsim</span> <span class="kn">import</span> <span class="n">validate_quantsim_inputs</span><span class="p">,</span> <span class="n">extract_global_quantizer_args</span><span class="p">,</span> <span class="n">VALID_ENCODING_VERSIONS</span>
<span class="kn">from</span> <span class="nn">aimet_common.quant_utils</span> <span class="kn">import</span> <span class="n">get_conv_accum_bounds</span>
<span class="kn">from</span> <span class="nn">aimet_common.utils</span> <span class="kn">import</span> <span class="n">deprecated</span><span class="p">,</span> <span class="n">_red</span>

<span class="kn">from</span> <span class="nn">aimet_torch.v1.nn.modules.custom</span> <span class="kn">import</span> <span class="n">MatMul</span>
<span class="kn">from</span> <span class="nn">aimet_torch.quantsim_config.quantsim_config</span> <span class="kn">import</span> <span class="n">QuantSimConfigurator</span>
<span class="kn">from</span> <span class="nn">aimet_torch.v1.qc_quantize_op</span> <span class="kn">import</span> <span class="n">QcQuantizeStandAloneBase</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeOpMode</span><span class="p">,</span> \
    <span class="n">StaticGridQuantWrapper</span><span class="p">,</span> <span class="n">LearnedGridQuantWrapper</span><span class="p">,</span> <span class="n">NativeTorchQuantWrapper</span><span class="p">,</span> <span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">,</span> <span class="n">QUANTIZER_TYPE_OUTPUT</span>
<span class="kn">from</span> <span class="nn">aimet_torch.v1.tensor_quantizer</span> <span class="kn">import</span> <span class="n">initialize_learned_grid_quantizer_attributes</span><span class="p">,</span> <span class="n">TensorQuantizer</span>
<span class="kn">from</span> <span class="nn">aimet_torch.v1.qc_quantize_op</span> <span class="kn">import</span> <span class="n">get_encoding_by_quantizer</span> <span class="k">as</span> <span class="n">_get_encoding_by_quantizer</span>
<span class="kn">from</span> <span class="nn">aimet_torch</span> <span class="kn">import</span> <span class="n">torchscript_utils</span><span class="p">,</span> <span class="n">utils</span><span class="p">,</span> <span class="n">onnx_utils</span>
<span class="kn">from</span> <span class="nn">aimet_torch.onnx_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">OnnxSaver</span><span class="p">,</span>
    <span class="n">OnnxExportApiArgs</span><span class="p">,</span>
    <span class="n">CustomMarker</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">aimet_torch.meta.connectedgraph</span> <span class="kn">import</span> <span class="n">ConnectedGraph</span><span class="p">,</span> <span class="n">Op</span>
<span class="kn">from</span> <span class="nn">aimet_torch.v1.qc_quantize_recurrent</span> <span class="kn">import</span> <span class="n">QcQuantizeRecurrent</span>
<span class="kn">from</span> <span class="nn">aimet_torch.quantsim_config.builder</span> <span class="kn">import</span> <span class="n">LazyQuantizeWrapper</span>
<span class="kn">from</span> <span class="nn">aimet_torch.experimental.v2.quantsim.export_utils</span> <span class="kn">import</span> <span class="n">_export_to_1_0_0</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">AimetLogger</span><span class="o">.</span><span class="n">get_area_logger</span><span class="p">(</span><span class="n">AimetLogger</span><span class="o">.</span><span class="n">LogAreas</span><span class="o">.</span><span class="n">Quant</span><span class="p">)</span>

<span class="c1"># If a torch module type is in this dictionary, call the corresponding quantized module constructor instead of wrapping</span>
<span class="c1"># it with QcQuantizeWrapper.</span>
<span class="n">qc_quantize_modules_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">RNN</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">LSTM</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">GRU</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span>
<span class="p">}</span>

<span class="c1"># Length of the string &#39;._module_to_wrap&#39;</span>
<span class="n">MODULE_TO_WRAP_STRING_REVERSE_INDEX</span> <span class="o">=</span> <span class="o">-</span><span class="mi">16</span>

<span class="n">MAP_PYMO_TO_ROUND_MODE</span> <span class="o">=</span> <span class="p">{</span><span class="n">libpymo</span><span class="o">.</span><span class="n">RoundingMode</span><span class="o">.</span><span class="n">ROUND_NEAREST</span><span class="p">:</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                          <span class="n">libpymo</span><span class="o">.</span><span class="n">RoundingMode</span><span class="o">.</span><span class="n">ROUND_STOCHASTIC</span><span class="p">:</span> <span class="s1">&#39;stochastic&#39;</span><span class="p">}</span>

<span class="n">SUPPORTED_KERNELS_ACTION</span> <span class="o">=</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">warn_on_error</span>



<div class="viewcode-block" id="QuantParams"><a class="viewcode-back" href="../../../api_docs/torch_bias_correction.html#aimet_torch.v1.quantsim.QuantParams">[docs]</a><span class="k">class</span> <span class="nc">QuantParams</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data type to hold quantization related params.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">weight_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">act_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">round_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                 <span class="n">quant_scheme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">QuantScheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                 <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>

<span class="sd">        :param weight_bw: Weight bitwidth (4-31) to use for quantizing layer weights. Default = 8</span>
<span class="sd">        :param act_bw: Activation bitwidth(4-31) to use for quantizing layer activations. Default = 8</span>
<span class="sd">        :param round_mode: Rounding mode. Supported options are &#39;nearest&#39; or &#39;stochastic&#39;</span>
<span class="sd">        :param quant_scheme: Quantization scheme. Supported options are &#39;tf_enhanced&#39; or &#39;tf&#39; or using Quant Scheme Enum</span>
<span class="sd">                             QuantScheme.post_training_tf or QuantScheme.post_training_tf_enhanced</span>
<span class="sd">        :param config_file: Path to Configuration file for model quantizers</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weight_bw</span> <span class="o">=</span> <span class="n">weight_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">act_bw</span> <span class="o">=</span> <span class="n">act_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">round_mode</span> <span class="o">=</span> <span class="n">round_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">quant_scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_file</span> <span class="o">=</span> <span class="n">config_file</span></div>


<span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">ExportableQuantModule</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines the minimum interface requirements for exporting encodings from a module.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">export_input_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of input encodings, each represented as a List of Dicts</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">export_output_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of output encodings, each represented as a List of Dicts</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">export_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dict of {param name: param encodings}, with each encoding represented as a List of Dicts</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">import_input_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">encodings</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">],</span>
                               <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                               <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                               <span class="n">requires_grad</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
                               <span class="n">allow_overwrite</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import input encodings represented in below format:</span>
<span class="sd">        {</span>
<span class="sd">            &#39;0&#39;: dict,</span>
<span class="sd">            &#39;1&#39;: dict,</span>
<span class="sd">            ...</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">import_output_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="n">encodings</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">],</span>
                                <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                <span class="n">requires_grad</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
                                <span class="n">allow_overwrite</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import output encodings represented in below format:</span>
<span class="sd">        {</span>
<span class="sd">            &#39;0&#39;: dict,</span>
<span class="sd">            &#39;1&#39;: dict,</span>
<span class="sd">            ...</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">import_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">encodings</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">],</span>
                               <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                               <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                               <span class="n">requires_grad</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
                               <span class="n">allow_overwrite</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import parameter encodings represented in below format:</span>
<span class="sd">        {</span>
<span class="sd">            &#39;param_name_0&#39;: [dict, dict, ...],</span>
<span class="sd">            &#39;param_name_1&#39;: [dict, dict, ...],</span>
<span class="sd">            ...</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_original_module</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the floating point version of quantized module</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="c1"># Types of modules which cannot be quantized</span>
<span class="n">unquantizable_modules</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">quantized_modules</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">QcQuantizeWrapper</span><span class="p">,</span>
    <span class="n">QcQuantizeStandAloneBase</span><span class="p">,</span>
    <span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
    <span class="n">ExportableQuantModule</span><span class="p">,</span>
    <span class="n">LazyQuantizeWrapper</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="QuantizationSimModel"><a class="viewcode-back" href="../../../api_docs/torch_quantsim.html#aimet_torch.v1.quantsim.QuantizationSimModel">[docs]</a><span class="k">class</span> <span class="nc">QuantizationSimModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements mechanism to add quantization simulations ops to a model. This allows for off-target simulation of</span>
<span class="sd">    inference accuracy. Also allows the model to be fine-tuned to counter the effects of quantization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-arguments, too-many-instance-attributes, too-many-locals, too-many-public-methods</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                 <span class="n">quant_scheme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                 <span class="n">rounding_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">default_data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span> <span class="o">=</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for QuantizationSimModel.</span>

<span class="sd">        :param model: Model to add simulation ops to</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph. If the model has more than one input,</span>
<span class="sd">                            pass a tuple. User is expected to place the tensors on the appropriate device.</span>
<span class="sd">        :param quant_scheme: Quantization scheme. The Quantization scheme is used to compute the Quantization encodings.</span>
<span class="sd">                             There are multiple schemes available. Please refer the QuantScheme enum definition.</span>
<span class="sd">        :param rounding_mode: Rounding mode. Supported options are &#39;nearest&#39; or &#39;stochastic&#39;</span>
<span class="sd">        :param default_output_bw: Default bitwidth (4-31) to use for quantizing all layer inputs and outputs</span>
<span class="sd">        :param default_param_bw: Default bitwidth (4-31) to use for quantizing all layer parameters</span>
<span class="sd">        :param in_place: If True, then the given &#39;model&#39; is modified in-place to add quant-sim nodes.</span>
<span class="sd">                Only suggested use of this option is when the user wants to avoid creating a copy of the model</span>
<span class="sd">        :param config_file: Path to Configuration file for model quantizers</span>
<span class="sd">        :param default_data_type: Default data type to use for quantizing all layer inputs, outputs and parameters.</span>
<span class="sd">                                 Possible options are QuantizationDataType.int and QuantizationDataType.float.</span>
<span class="sd">                                 Note that the mode default_data_type=QuantizationDataType.float is only supported with</span>
<span class="sd">                                 default_output_bw=16 or 32 and default_param_bw=16 or 32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform sanity checks on inputs</span>
        <span class="n">validate_quantsim_inputs</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span> <span class="n">rounding_mode</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">,</span>
                                 <span class="n">default_data_type</span><span class="p">)</span>
        <span class="c1"># save some parameters</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="o">=</span> <span class="n">ConnectedGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">TracingCheckError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">quant_scheme</span> <span class="o">==</span> <span class="s1">&#39;tf&#39;</span><span class="p">:</span>
                <span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span>
            <span class="k">elif</span> <span class="n">quant_scheme</span> <span class="o">==</span> <span class="s1">&#39;tf_enhanced&#39;</span><span class="p">:</span>
                <span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span>
            <span class="k">elif</span> <span class="n">quant_scheme</span> <span class="o">==</span> <span class="s1">&#39;percentile&#39;</span><span class="p">:</span>
                <span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">=</span> <span class="n">quant_scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rounding_mode</span> <span class="o">=</span> <span class="n">rounding_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span> <span class="o">=</span> <span class="n">default_output_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_param_bw</span> <span class="o">=</span> <span class="n">default_param_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config_file</span> <span class="o">=</span> <span class="n">config_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_percentile_value</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># default percentile value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Add quantization layers</span>
        <span class="n">inout_tensor_shape</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_inout_tensor_shape_per_module</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>
        <span class="n">num_inout_tensors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_num_inout_tensors_from_tensor_shape_dict</span><span class="p">(</span><span class="n">inout_tensor_shape</span><span class="p">)</span>
        <span class="n">inout_tensors_dtypes_for_cast_ops</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_inout_tensors_dtypes_for_cast_modules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_quantization_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_tensor_quantizers_for_consts</span><span class="p">(</span><span class="n">inout_tensor_shape</span><span class="p">)</span>

        <span class="c1"># Disable bias quantization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_param_from_quantization</span><span class="p">(</span><span class="s2">&quot;bias&quot;</span><span class="p">)</span>

        <span class="n">quantsim_configurator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">configure_quantization_ops</span><span class="p">(</span><span class="n">config_file</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">,</span>
                                                                <span class="n">default_data_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">quant_args</span> <span class="o">=</span> <span class="n">extract_global_quantizer_args</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span> <span class="n">quantsim_configurator</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_output_quantizers_for_specific_cast_ops</span><span class="p">(</span><span class="n">inout_tensors_dtypes_for_cast_ops</span><span class="p">)</span>

        <span class="c1"># pylint: disable=protected-access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hw_version</span> <span class="o">=</span> <span class="n">quantsim_configurator</span><span class="o">.</span><span class="n">_get_hw_version</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_supported_kernels</span> <span class="o">=</span> <span class="n">quantsim_configurator</span><span class="o">.</span><span class="n">get_supported_kernels</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_supported_kernels_for_quantizers</span><span class="p">(</span><span class="n">SUPPORTED_KERNELS_ACTION</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_exception_rules</span><span class="p">()</span>

        <span class="c1"># Initialize real wrappers using collected information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_realize_quant_wrappers_in_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_realize_quant_wrappers_in_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare QuantSim for compute encodings. Resets encodings for each quantizable layer and sets mode to Analysis.</span>
<span class="sd">        Realize quant wrappers using collected information in LazyQuantWrapper.</span>

<span class="sd">        :param model: model containing modules wrapped with LazyQuantWrapper</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">):</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="n">module_ref</span><span class="o">.</span><span class="n">realize_v1_wrapper</span><span class="p">()</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_realize_quant_wrappers_in_model</span><span class="p">(</span><span class="n">module_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_supported_kernels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return _supported_kernels parsed from the config file</span>
<span class="sd">        :return: Dictionary containing supported_kernels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_supported_kernels</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty-printed output indicating where in the model, quantizers have been activated</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">prefix_string</span><span class="si">}</span><span class="s1">: bw=</span><span class="si">{</span><span class="n">quantizer</span><span class="o">.</span><span class="n">bitwidth</span><span class="si">}</span><span class="s1">, &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;encoding-present=</span><span class="si">{</span><span class="nb">bool</span><span class="p">(</span><span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    </span><span class="si">{</span><span class="n">quantizer</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">prefix_string</span><span class="si">}</span><span class="s1">: Not quantized</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;  -------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">newline</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;-------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Quantized Model Report</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;-------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_qc_quantized_layers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">):</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Layer: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">layer_name</span><span class="p">))</span>

            <span class="c1"># Inputs</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Input[</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">):</span>
                    <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Input[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

            <span class="c1"># Params</span>
            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Param[</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

            <span class="c1"># Outputs</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Output[</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">):</span>
                    <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Output[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">prepare_sim_for_compute_encodings</span><span class="p">(</span><span class="n">sim</span><span class="p">:</span> <span class="s1">&#39;QuantizationSimModel&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare QuantSim for compute encodings. Resets encodings for each quantizable layer and sets mode to Analysis.</span>

<span class="sd">        :param sim: QuantSim to prepare</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">quantized_layers</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">_get_qc_quantized_layers</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quantized_layers</span><span class="p">:</span>
            <span class="c1"># Clear stats and encodings if they are present</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">reset_encodings</span><span class="p">()</span>

            <span class="c1"># And set the mode to analysis</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ANALYSIS</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quantized_layers</span><span class="p">:</span>
            <span class="c1"># call only when quant scheme is percentile</span>
            <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span><span class="p">:</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">set_percentile_value</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">_percentile_value</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_layer_encodings_for_sim</span><span class="p">(</span><span class="n">sim</span><span class="p">:</span> <span class="s1">&#39;QuantizationSimModel&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute encodings for each quantizable layer in sim after forward pass has been called.</span>

<span class="sd">        :param sim: QuantSim to compute encodings for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">quantized_layers</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">_get_qc_quantized_layers</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="c1"># Get the computed per-layer encodings and log them</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quantized_layers</span><span class="p">:</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">compute_encoding</span><span class="p">()</span>

            <span class="c1"># Before we return we set the mode to active - meaning ready for quantize/de-quantize</span>
            <span class="c1"># for layers with valid_encoding, otherwise we set to pass through</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                <span class="n">sim</span><span class="o">.</span><span class="n">set_mode_for_recurrent_module</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># By default we want to set the Quantization wrappers to ACTIVE mode</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">)</span>

        <span class="n">sim</span><span class="o">.</span><span class="n">replace_wrappers_for_quantize_dequantize</span><span class="p">()</span>

<div class="viewcode-block" id="QuantizationSimModel.compute_encodings"><a class="viewcode-back" href="../../../api_docs/torch_quantsim.html#aimet_torch.v1.quantsim.QuantizationSimModel.compute_encodings">[docs]</a>    <span class="k">def</span> <span class="nf">compute_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_pass_callback</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes encodings for all quantization sim nodes in the model. It is also used to find initial encodings for</span>
<span class="sd">        Range Learning</span>

<span class="sd">        :param forward_pass_callback: A callback function that simply runs forward passes on the model. This callback</span>
<span class="sd">            function should use representative data for the forward pass, so the calculated encodings work for all</span>
<span class="sd">            data samples. This callback internally chooses the number of data samples it wants to use for calculating</span>
<span class="sd">            encodings.</span>
<span class="sd">        :param forward_pass_callback_args: These argument(s) are passed to the forward_pass_callback as-is. Up to</span>
<span class="sd">            the user to determine the type of this parameter. E.g. could be simply an integer representing the number</span>
<span class="sd">            of data samples to use. Or could be a tuple of parameters or an object representing something more complex.</span>
<span class="sd">            If set to None, forward_pass_callback will be invoked with no parameters.</span>
<span class="sd">        :return: None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">prepare_sim_for_compute_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Run forward iterations so we can collect statistics to compute the appropriate encodings</span>
        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">forward_pass_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">)</span>

        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">compute_layer_encodings_for_sim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set_mode_for_recurrent_module</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets Recurrent module to active or pass through mode based on quantizer state</span>

<span class="sd">        :param layer:  Qc Quantizer layer for recurrent module</span>
<span class="sd">        :param name:  layer name</span>
<span class="sd">        :return: True if the encoding is invalid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">output_quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Encoding for </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">: min=</span><span class="si">%f</span><span class="s2">, max=</span><span class="si">%f</span><span class="s2">, offset=</span><span class="si">%f</span><span class="s2">. delta=</span><span class="si">%f</span><span class="s2">, bw=</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
                                 <span class="n">name</span><span class="p">,</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                                 <span class="n">encoding</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">bw</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">input_quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">encoding</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Encoding for </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">: min=</span><span class="si">%f</span><span class="s2">, max=</span><span class="si">%f</span><span class="s2">, offset=</span><span class="si">%f</span><span class="s2">. delta=</span><span class="si">%f</span><span class="s2">, bw=</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
                                 <span class="n">name</span><span class="p">,</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                                 <span class="n">encoding</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">bw</span><span class="p">)</span>

        <span class="n">layer</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_percentile_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentile_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the percentile value to be used while computing encodings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">percentile_value</span> <span class="o">&lt;</span> <span class="mi">90</span> <span class="ow">or</span> <span class="n">percentile_value</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Percentile value must be in range [90, 100]&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_percentile_value</span> <span class="o">=</span> <span class="n">percentile_value</span>

<div class="viewcode-block" id="QuantizationSimModel.export"><a class="viewcode-back" href="../../../api_docs/torch_quantsim.html#aimet_torch.v1.quantsim.QuantizationSimModel.export">[docs]</a>    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
               <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">export_to_torchscript</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">use_embedded_encodings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">export_model</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
               <span class="n">filename_prefix_encodings</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method exports out the quant-sim model so it is ready to be run on-target.</span>

<span class="sd">        Specifically, the following are saved:</span>

<span class="sd">        1. The sim-model is exported to a regular PyTorch model without any simulation ops</span>
<span class="sd">        2. The quantization encodings are exported to a separate JSON-formatted file that can</span>
<span class="sd">           then be imported by the on-target runtime (if desired)</span>
<span class="sd">        3. Optionally, An equivalent model in ONNX format is exported. In addition, nodes in the ONNX model are named</span>
<span class="sd">           the same as the corresponding PyTorch module names. This helps with matching ONNX node to their quant</span>
<span class="sd">           encoding from #2.</span>

<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph. It is required for the dummy_input to</span>
<span class="sd">                be placed on CPU.</span>
<span class="sd">        :param onnx_export_args: Optional export argument with onnx specific overrides provided as a dictionary or</span>
<span class="sd">            OnnxExportApiArgs object. If not provided, defaults to &quot;opset_version&quot; = None, &quot;input_names&quot; = None,</span>
<span class="sd">            &quot;output_names&quot; = None, and for torch version &lt; 1.10.0, &quot;enable_onnx_checker&quot; = False.</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops. Defaults to False.</span>
<span class="sd">        :param export_to_torchscript: If True, export to torchscript. Export to onnx otherwise. Defaults to False.</span>
<span class="sd">        :param use_embedded_encodings: If True, another onnx model embedded with fakequant nodes will be exported</span>
<span class="sd">        :param export_model: If True, then ONNX model is exported. When False, only encodings are exported. User should</span>
<span class="sd">                            disable (False) this flag only if the corresponding ONNX model already exists in the path</span>
<span class="sd">                            specified</span>
<span class="sd">        :param filename_prefix_encodings: File name prefix to be used when saving encodings.</span>
<span class="sd">                                          If None, then user defaults to filename_prefix value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">quantsim</span><span class="o">.</span><span class="n">encoding_version</span> <span class="o">==</span> <span class="s1">&#39;0.6.1&#39;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">_red</span><span class="p">(</span><span class="s2">&quot;Encoding version 0.6.1 will be deprecated in a future release, with version 1.0.0 becoming &quot;</span>
                       <span class="s2">&quot;the default. If your code depends on parsing the exported encodings file, ensure that it is &quot;</span>
                       <span class="s2">&quot;updated to be able to parse 1.0.0 format.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;To swap the encoding version to 1.0.0, run the following lines prior to calling quantsim &quot;</span>
                       <span class="s2">&quot;export:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;from aimet_common import quantsim</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;quantsim.encoding_version = &#39;1.0.0&#39;&quot;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">warning_str</span> <span class="o">=</span> <span class="s1">&#39;Exporting encodings to yaml will be deprecated in a future release. Ensure that your &#39;</span> \
                      <span class="s1">&#39;code can work with the exported files ending in &quot;.encodings&quot; which are saved using json &#39;</span> \
                      <span class="s1">&#39;format. For the time being, if yaml export is needed, set aimet_common.utils.SAVE_TO_YAML to &#39;</span> \
                      <span class="s1">&#39;True.&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warning_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename_prefix_encodings</span><span class="p">:</span>
            <span class="n">filename_prefix_encodings</span> <span class="o">=</span> <span class="n">filename_prefix</span>

        <span class="k">if</span> <span class="n">quantsim</span><span class="o">.</span><span class="n">encoding_version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VALID_ENCODING_VERSIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Encoding version </span><span class="si">{</span><span class="n">quantsim</span><span class="o">.</span><span class="n">encoding_version</span><span class="si">}</span><span class="s1"> not in set of valid encoding &#39;</span>
                                      <span class="sa">f</span><span class="s1">&#39;versions </span><span class="si">{</span><span class="n">VALID_ENCODING_VERSIONS</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="c1"># save the quantized model and encodings</span>
        <span class="n">model_filename</span> <span class="o">=</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.pth&#39;</span>
        <span class="n">model_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">model_filename</span><span class="p">)</span>

        <span class="c1"># Create a version of the model without any quantization ops</span>
        <span class="n">model_to_export</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_original_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">qdq_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model_to_export</span><span class="p">,</span> <span class="n">model_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">onnx_export_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">onnx_export_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;opset_version&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="s1">&#39;input_names&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="s1">&#39;output_names&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1.10.0&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onnx_export_args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">onnx_export_args</span><span class="p">[</span><span class="s1">&#39;enable_onnx_checker&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">log_with_error_and_assert_if_false</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">onnx_export_args</span><span class="p">,</span> <span class="p">(</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)),</span>
                                           <span class="n">logger</span><span class="p">,</span>
                                           <span class="sa">f</span><span class="s1">&#39;unsupported opt_args type=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">onnx_export_args</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_embedded_encodings</span><span class="p">:</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">save_model_with_embedded_quantization_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span>
                                                                             <span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">export_to_torchscript</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">export_to_torchscript</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">export_torch_script_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">filename_prefix_encodings</span><span class="p">,</span>
                                                             <span class="n">model_to_export</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                             <span class="n">dummy_input</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">export_onnx_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">model_to_export</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                     <span class="n">dummy_input</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span><span class="p">,</span> <span class="n">quantizer_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quant_args</span><span class="p">,</span>
                                                     <span class="n">export_model</span><span class="o">=</span><span class="n">export_model</span><span class="p">,</span>
                                                     <span class="n">filename_prefix_encodings</span><span class="o">=</span><span class="n">filename_prefix_encodings</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">export_torch_script_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                                <span class="n">filename_prefix_encodings</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                                <span class="n">original_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                                                <span class="n">sim_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                                                <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                                                <span class="n">excluded_layer_names</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method exports a torchscript mode and the corresponding encodings</span>

<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param filename_prefix_encodings: File name prefix for encodings. Can be same as filename_prefix</span>
<span class="sd">        :param original_model: model without the quantsim wrappers</span>
<span class="sd">        :param sim_model: model with the quantsim wrappers</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph.</span>
<span class="sd">        :param excluded_layer_names: List of names of layers that have been excluded from quantization.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create torchscript model and obtain node to i/o tensor name map</span>
        <span class="n">ts_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.torchscript.pth&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">original_model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">torchscript_utils</span><span class="o">.</span><span class="n">create_torch_script_model</span><span class="p">(</span><span class="n">ts_path</span><span class="p">,</span> <span class="n">original_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>

            <span class="n">trace</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ts_path</span><span class="p">)</span>
            <span class="n">torch_script_node_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span> <span class="o">=</span> \
                <span class="n">torchscript_utils</span><span class="o">.</span><span class="n">get_node_to_io_tensor_names_map</span><span class="p">(</span><span class="n">original_model</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>

        <span class="c1"># Export encodings</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_export_encodings_to_files</span><span class="p">(</span><span class="n">sim_model</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix_encodings</span><span class="p">,</span>
                                                        <span class="n">torch_script_node_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">,</span>
                                                        <span class="n">excluded_layer_names</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">export_onnx_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                                        <span class="n">sim_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                                        <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                        <span class="n">module_marker_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">is_conditional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">excluded_layer_names</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">quantizer_args</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">export_model</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                        <span class="n">filename_prefix_encodings</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method exports a onnx model and the corresponding encodings</span>

<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param original_model: model without the quantsim wrappers</span>
<span class="sd">        :param sim_model: model with the quantsim wrappers</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph.</span>
<span class="sd">        :param onnx_export_args: Additional onnx export args including export api overrides</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">               multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">               ops.</span>
<span class="sd">        :param module_marker_map: Maps module names to traced custom markers (only used for conditional models)</span>
<span class="sd">        :param is_conditional: True if model is conditional, False otherwise</span>
<span class="sd">        :param excluded_layer_names: List of names of layers that have been excluded from quantization.</span>
<span class="sd">        :param export_model: If True, then ONNX model is exported. When False, only encodings are exported. User should</span>
<span class="sd">                            disable (False) this flag only if the corresponding ONNX model already exists in the path</span>
<span class="sd">                            specified</span>
<span class="sd">        :param filename_prefix_encodings: File name prefix to be used when saving encodings.</span>
<span class="sd">                                          If None, then user defaults to filename_prefix value</span>
<span class="sd">        :return: None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename_prefix_encodings</span><span class="p">:</span>
            <span class="n">filename_prefix_encodings</span> <span class="o">=</span> <span class="n">filename_prefix</span>
        <span class="n">onnx_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.onnx&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">export_model</span><span class="p">:</span>
            <span class="n">OnnxSaver</span><span class="o">.</span><span class="n">create_onnx_model_with_pytorch_layer_names</span><span class="p">(</span><span class="n">onnx_path</span><span class="p">,</span> <span class="n">original_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span> <span class="n">is_conditional</span><span class="p">,</span>
                                                                 <span class="n">module_marker_map</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">onnx_path</span><span class="p">),</span> <span class="s1">&#39;The onnx model does not exist in the location specified. Please re-run export&#39;</span> \
                                          <span class="s1">&#39;with export_model flag as True or check path/file_name&#39;</span>
        <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">onnx_path</span><span class="p">)</span>
        <span class="n">onnx_node_to_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span> <span class="o">=</span> <span class="n">OnnxSaver</span><span class="o">.</span><span class="n">get_onnx_node_to_io_tensor_names_map</span><span class="p">(</span><span class="n">onnx_model</span><span class="p">)</span>

        <span class="c1"># Export encodings</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_export_encodings_to_files</span><span class="p">(</span><span class="n">sim_model</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix_encodings</span><span class="p">,</span>
                                                        <span class="n">onnx_node_to_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">,</span>
                                                        <span class="n">excluded_layer_names</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">,</span>
                                                        <span class="n">quantizer_args</span><span class="o">=</span><span class="n">quantizer_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">export_weights_to_safetensors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exports the updated weights in the safetensors format</span>

<span class="sd">        :param path: Path to save file</span>
<span class="sd">        :param filename_prefix: Filename to use for saved file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">requires_grad</span> <span class="k">else</span> <span class="n">tensor</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

        <span class="c1"># Save state dict in safetensors file</span>
        <span class="n">unwrapped_model</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">get_original_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">unwrapped_model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">to_numpy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mpp_meta</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;mpp_meta&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span>

        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.safetensors&#39;</span><span class="p">)</span>
        <span class="n">save_safetensor_file</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save_encodings_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save encodings in the model to json.</span>

<span class="sd">        :param path: Path to save file</span>
<span class="sd">        :param filename_prefix: Filename to use for saved file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">activation_encodings</span><span class="p">,</span> <span class="n">param_encodings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_activation_param_encodings</span><span class="p">()</span>
        <span class="n">encodings_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;activation_encodings&#39;</span><span class="p">:</span> <span class="n">activation_encodings</span><span class="p">,</span> <span class="s1">&#39;param_encodings&#39;</span><span class="p">:</span> <span class="n">param_encodings</span><span class="p">}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.json&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">encoding_json</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">encodings_dict</span><span class="p">,</span> <span class="n">encoding_json</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_activation_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get activation and param encodings from sim.model.</span>

<span class="sd">        :return: Tuple of activation and param encodings dictionaries mapping torch module names to encodings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">activation_encodings</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">param_encodings</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">export_input_encodings</span><span class="p">()):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">encoding</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">export_output_encodings</span><span class="p">()):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">encoding</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">export_param_encodings</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">encoding</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">param_encodings</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>

        <span class="k">return</span> <span class="n">activation_encodings</span><span class="p">,</span> <span class="n">param_encodings</span>

    <span class="k">def</span> <span class="nf">exclude_layers_from_quantization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layers_to_exclude</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Excludes certain layers from being quantized-dequantized by the simulator</span>
<span class="sd">        :param layers_to_exclude: List of torch layers to exclude</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Save the excluded layer names. Do not save the modules since the wrapper removal depends on</span>
        <span class="c1"># reference count to automatically remove the layers.</span>
        <span class="n">module_to_name_dict</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_module_to_name_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">quant_layers_to_exclude</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">quant_cls</span> <span class="o">=</span> <span class="p">(</span><span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
                     <span class="n">LazyQuantizeWrapper</span><span class="p">,</span>
                     <span class="n">ExportableQuantModule</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">layers_to_exclude</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">quant_cls</span><span class="p">):</span>
                    <span class="n">quant_layers_to_exclude</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
                    <span class="n">excluded_module_name</span> <span class="o">=</span> <span class="n">module_to_name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">excluded_module_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_quantization_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">quant_layers_to_exclude</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exclude_param_from_quantization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name_to_exclude</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Excludes all parameters matching &#39;param_name&#39; from quantization</span>
<span class="sd">        :param param_name_to_exclude: Name of the parameter to exclude</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">param_name_to_exclude</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="n">param_name_to_exclude</span><span class="p">]</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_replace_quantization_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively remove quantization wrappers from all appropriate modules starting with a given module</span>
<span class="sd">        :param model: model for which PostTrainingWrapper gets replaced with Trainable wrapped module</span>
<span class="sd">        :param device: device on which model is present</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">StaticGridQuantWrapper</span><span class="p">):</span>
                <span class="c1"># Create a Trainable wrapper and copy properties of PostTrainingWrapper to the Trainable wrapper</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_and_initialize_trainable_wrapper</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                <span class="c1"># Set Recurrent layer for training mode</span>
                <span class="n">module_ref</span><span class="o">.</span><span class="n">construct_and_initialize_trainable_quantizers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span><span class="p">)</span>

            <span class="c1"># Recursively call children modules if present</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replace_quantization_wrapper</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_and_initialize_trainable_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_training_module</span><span class="p">:</span> <span class="n">StaticGridQuantWrapper</span><span class="p">,</span>
                                                    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LearnedGridQuantWrapper</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies following tensor quantizer attributes from StaticGridQuantWrapper to LearnedGridQuantWrapper</span>
<span class="sd">        to avoid any mismatch.</span>
<span class="sd">            - enabled</span>
<span class="sd">            - bitwidth</span>
<span class="sd">            - encoding</span>
<span class="sd">            - use_symmetric_encodings</span>
<span class="sd">            - use_strict_symmetric</span>
<span class="sd">            - use_unsigned_symmetric</span>

<span class="sd">        :param post_training_module: StaticGridQuantWrapper wrapped module</span>
<span class="sd">        :param device: device on which model is present</span>
<span class="sd">        :return: trainable_module: QcTrainable wrapper module</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">post_training_module</span><span class="o">.</span><span class="n">_module_to_wrap</span>

        <span class="n">num_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">)</span>
        <span class="n">num_outputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">)</span>

        <span class="c1"># Creating a LearnedGridQuantWrapper module</span>
        <span class="n">trainable_module</span> <span class="o">=</span> <span class="n">LearnedGridQuantWrapper</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_param_bw</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rounding_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span><span class="p">,</span>
                                                   <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">num_inputs</span><span class="o">=</span><span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="n">num_outputs</span><span class="p">,</span>
                                                   <span class="n">data_type</span><span class="o">=</span><span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># Copy user settable attributes for outputs</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">):</span>
            <span class="n">initialize_learned_grid_quantizer_attributes</span><span class="p">(</span><span class="n">trainable_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">quantizer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trainable_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">encoding_min_max_fixed_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trainable_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">freeze_encoding</span><span class="p">()</span>
        <span class="c1"># Copy user settable attributes for inputs</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">):</span>
            <span class="n">initialize_learned_grid_quantizer_attributes</span><span class="p">(</span><span class="n">trainable_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">quantizer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trainable_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">encoding_min_max_fixed_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trainable_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">freeze_encoding</span><span class="p">()</span>
        <span class="c1"># Copy user settable attributes for params</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">post_training_module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">learned_grid_quantizer</span> <span class="o">=</span> <span class="n">trainable_module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">initialize_learned_grid_quantizer_attributes</span><span class="p">(</span><span class="n">learned_grid_quantizer</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">learned_grid_quantizer</span><span class="o">.</span><span class="n">encoding_min_max_fixed_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">learned_grid_quantizer</span><span class="o">.</span><span class="n">freeze_encoding</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">trainable_module</span>

    <span class="k">def</span> <span class="nf">replace_wrappers_for_quantize_dequantize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces StaticGridWrapper with LearnedGridWrapper</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_init</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> \
                <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_enhanced_init</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">device</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># Model doesn&#39;t have any parameter.</span>
                <span class="c1"># Set device to cpu by default.</span>
                <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_replace_quantization_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_quantsim_inputs</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="p">],</span> <span class="n">rounding_mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                  <span class="n">default_param_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span> <span class="o">=</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform sanity checks on inputs to QuantSim</span>

<span class="sd">        NOTE: This method will be deprecated.</span>
<span class="sd">              Call aimet_common.quantsim.validate_quantsim_inputs directly instead.</span>

<span class="sd">        :param quant_scheme: Quantization scheme. Supported options are &#39;tf_enhanced&#39; or &#39;tf&#39; or using Quant Scheme Enum</span>
<span class="sd">                             QuantScheme.post_training_tf or QuantScheme.post_training_tf_enhanced</span>
<span class="sd">        :param rounding_mode: Rounding mode. Supported options are &#39;nearest&#39; or &#39;stochastic&#39;</span>
<span class="sd">        :param default_output_bw: Default bitwidth (4-31) to use for quantizing layer inputs and outputs</span>
<span class="sd">        :param default_param_bw: Default bitwidth (4-31) to use for quantizing layer parameters</span>
<span class="sd">        :param data_type: Data type of the quantized values (int or float).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_quantsim_inputs</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span>
                                 <span class="n">rounding_mode</span><span class="p">,</span>
                                 <span class="n">default_output_bw</span><span class="p">,</span>
                                 <span class="n">default_param_bw</span><span class="p">,</span>
                                 <span class="n">data_type</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_next_downstream_modules</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
        <span class="n">downstream_modules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">succeeding_op</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">consumers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">succeeding_op</span><span class="o">.</span><span class="n">get_module</span><span class="p">():</span>
                <span class="n">downstream_modules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">succeeding_op</span><span class="o">.</span><span class="n">get_module</span><span class="p">())</span>

            <span class="k">elif</span> <span class="n">succeeding_op</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CG_SPLIT</span><span class="p">:</span>
                <span class="n">downstream_modules</span> <span class="o">+=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_find_next_downstream_modules</span><span class="p">(</span><span class="n">succeeding_op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">downstream_modules</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_torch_encodings_for_missing_layers</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span><span class="c1"># pylint: disable=too-many-branches</span>
                                                <span class="n">missing_activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                <span class="n">missing_param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add given layer param and activation encodings to respective dictionaries to be used for exporting torch encodings</span>
<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name: Name of the layer</span>
<span class="sd">        :param missing_activation_encodings_torch: dictionary of activation encodings which maps pytorch names to encodings</span>
<span class="sd">        :param missing_param_encodings: dictionary of param encodings</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
            <span class="c1"># --------------------------------------</span>
            <span class="c1"># Update encodings for Input activations</span>
            <span class="c1"># --------------------------------------</span>
            <span class="n">input_encodings</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">export_input_encodings</span><span class="p">()</span>
            <span class="c1"># skip layer if it has no input encodings.</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">input_encodings</span><span class="p">):</span>
                <span class="k">return</span>

            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_encodings</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missing_activation_encodings_torch</span><span class="p">:</span>
                        <span class="n">missing_activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="n">QUANTIZER_TYPE_INPUT</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missing_activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]:</span>
                        <span class="n">missing_activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="c1"># Store encodings for a particular index so that they can be used to check if a quantizer was</span>
                    <span class="c1"># enabled or not</span>
                    <span class="n">missing_activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># ---------------------------------------</span>
            <span class="c1"># Update encodings for output activations</span>
            <span class="c1"># ---------------------------------------</span>
            <span class="n">output_encodings</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">export_output_encodings</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_encodings</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missing_activation_encodings_torch</span><span class="p">:</span>
                        <span class="n">missing_activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="n">QUANTIZER_TYPE_OUTPUT</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missing_activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]:</span>
                        <span class="n">missing_activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_OUTPUT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">missing_activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_OUTPUT</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># ---------------------------</span>
            <span class="c1"># Update encodings for Params</span>
            <span class="c1"># ---------------------------</span>
            <span class="k">for</span> <span class="n">orig_param_name</span><span class="p">,</span> <span class="n">param_encoding</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">export_param_encodings</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">param_name</span> <span class="o">=</span> <span class="n">layer_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">orig_param_name</span>
                <span class="k">if</span> <span class="n">param_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_param_set</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Param tensor {</span><span class="si">%s</span><span class="s1">} not found in valid param set&#39;</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">missing_param_encodings</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_encoding</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_export_encodings_to_files</span><span class="p">(</span><span class="n">sim_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                   <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">excluded_layer_names</span><span class="p">,</span>
                                   <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">quantizer_args</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the quantized model weight encodings</span>

<span class="sd">        :param sim_model: Quantsim model to export encodings for</span>
<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: filename to store exported weight encodings in json format</span>
<span class="sd">        :param op_to_io_tensor_map: Dictionary of layer to I/O tensor mapping from onnx or torch script model</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        :param excluded_layer_names: List of names of layers that have been excluded from quantization.</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :param quantizer_args</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=too-many-locals</span>

        <span class="c1"># Create a dictionary to export to JSON</span>
        <span class="n">activation_encodings_onnx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">activation_encodings_torch</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">missing_activation_encodings_torch</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">param_encodings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">missing_param_encodings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">layers_to_onnx_op_names</span> <span class="o">=</span> <span class="n">onnx_utils</span><span class="o">.</span><span class="n">get_layers_in_io_tensor_map</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">)</span>
        <span class="n">tensor_to_consumer_map</span> <span class="o">=</span> <span class="n">onnx_utils</span><span class="o">.</span><span class="n">get_tensor_to_consumer_map</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">)</span>
        <span class="n">layer_names_not_found</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tensor_to_quantizer_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">sim_model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="p">(</span><span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">has_valid_encodings</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># TODO: specifically call out dropout layers here since they are specifically switched out during export.</span>
            <span class="c1"># These ops should eventually be reworked as part of math invariant ops to ignore quantization altogether.</span>
            <span class="c1"># pylint: disable=protected-access</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">get_original_module</span><span class="p">(),</span> <span class="n">utils</span><span class="o">.</span><span class="n">DROPOUT_TYPES</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">layers_to_onnx_op_names</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">layer_names_not_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span>
                <span class="c1"># Some layers like transpose etc. may get removed after onnx export due to internal onnx optimization.</span>
                <span class="c1"># An error will be thrown if the exported encodings(without missing layers&#39;s encoding) are loaded back</span>
                <span class="c1"># to the sim model because the layers will be present in the sim model whereas the</span>
                <span class="c1"># corresponding encodings will not be present in the encoding file.</span>
                <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_torch_encodings_for_missing_layers</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span>
                                                                             <span class="n">missing_activation_encodings_torch</span><span class="p">,</span>
                                                                             <span class="n">missing_param_encodings</span><span class="p">,</span><span class="n">valid_param_set</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dicts_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                      <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                                                      <span class="n">param_encodings</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                      <span class="n">valid_param_set</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">,</span>
                                                                      <span class="n">tensor_to_consumer_map</span><span class="p">,</span> <span class="n">layers_to_onnx_op_names</span><span class="p">,</span>
                                                                      <span class="n">tensor_to_quantizer_map</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">layer_names_not_found</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The following layers were not found in the exported onnx model. Encodings for these layers&quot;</span>
                           <span class="s2">&quot; will not appear in the exported encodings file, however it will continue to&quot;</span>
                           <span class="s2">&quot; exist in torch encoding file:</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;This can be due to several reasons:</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">- The layer is set to quantize with float datatype, but was not exercised in compute &quot;</span>
                           <span class="s2">&quot;encodings. Not an issue if the layer is not meant to be run.</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">- The layer has valid encodings but was not seen while exporting to onnx using the dummy &quot;</span>
                           <span class="s2">&quot;input provided in sim.export(). Ensure that the dummy input covers all layers.&quot;</span><span class="p">,</span>
                           <span class="n">layer_names_not_found</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">quantsim</span><span class="o">.</span><span class="n">encoding_version</span> <span class="o">==</span> <span class="s1">&#39;0.6.1&#39;</span><span class="p">:</span>
            <span class="n">encodings_dict_onnx</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="n">quantsim</span><span class="o">.</span><span class="n">encoding_version</span><span class="p">,</span>
                                   <span class="s1">&#39;activation_encodings&#39;</span><span class="p">:</span> <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                   <span class="s1">&#39;param_encodings&#39;</span><span class="p">:</span> <span class="n">param_encodings</span><span class="p">,</span>
                                   <span class="s1">&#39;excluded_layers&#39;</span><span class="p">:</span> <span class="n">excluded_layer_names</span><span class="p">}</span>

            <span class="k">if</span> <span class="n">quantizer_args</span><span class="p">:</span>
                <span class="n">encodings_dict_onnx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;quantizer_args&#39;</span><span class="p">:</span> <span class="n">quantizer_args</span><span class="p">})</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Layers excluded from quantization: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">excluded_layer_names</span><span class="p">)</span>

            <span class="c1"># export weight encodings to output json file</span>
            <span class="n">encoding_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.encodings&#39;</span><span class="p">)</span>
            <span class="n">save_json_yaml</span><span class="p">(</span><span class="n">encoding_file_path</span><span class="p">,</span> <span class="n">encodings_dict_onnx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_export_to_1_0_0</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">activation_encodings_onnx</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">,</span> <span class="n">tensor_to_quantizer_map</span><span class="p">,</span>
                             <span class="n">excluded_layer_names</span><span class="p">,</span> <span class="n">quantizer_args</span><span class="p">)</span>

        <span class="c1"># Export torch.encodings used for saving/loading common to 0.6.1 and 1.0.0 versions</span>

        <span class="n">param_encodings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">missing_param_encodings</span><span class="p">)</span>
        <span class="n">activation_encodings_torch</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">missing_activation_encodings_torch</span><span class="p">)</span>
        <span class="n">encodings_dict_pytorch</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="n">quantsim</span><span class="o">.</span><span class="n">encoding_version</span><span class="p">,</span>
                                  <span class="s1">&#39;activation_encodings&#39;</span><span class="p">:</span> <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                  <span class="s1">&#39;param_encodings&#39;</span><span class="p">:</span> <span class="n">param_encodings</span><span class="p">,</span>
                                  <span class="s1">&#39;excluded_layers&#39;</span><span class="p">:</span> <span class="n">excluded_layer_names</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">quantizer_args</span><span class="p">:</span>
            <span class="n">encodings_dict_pytorch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;quantizer_args&#39;</span><span class="p">:</span> <span class="n">quantizer_args</span><span class="p">})</span>

        <span class="n">encoding_file_path_pytorch</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;_torch&#39;</span> <span class="o">+</span> <span class="s1">&#39;.encodings&#39;</span><span class="p">)</span>
        <span class="n">save_json_yaml</span><span class="p">(</span><span class="n">encoding_file_path_pytorch</span><span class="p">,</span> <span class="n">encodings_dict_pytorch</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_param_encodings_dict_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                               <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">tensor_to_quantizer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name : Name of the layer</span>
<span class="sd">        :param param_encodings: dictionary of param encodings</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">orig_param_name</span><span class="p">,</span> <span class="n">param_encoding</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">export_param_encodings</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">param_name</span> <span class="o">=</span> <span class="n">layer_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">orig_param_name</span>
            <span class="k">if</span> <span class="n">param_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_param_set</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Param tensor {</span><span class="si">%s</span><span class="s1">} not found in valid param set&#39;</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">param_encodings</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_encoding</span>
            <span class="n">tensor_to_quantizer_map</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="n">orig_param_name</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dicts_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                         <span class="n">activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                         <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                         <span class="n">tensor_to_consumer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                                         <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                                         <span class="n">tensor_to_quantizer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add given layer param and activation encodings to respective dictionaries to be used for exporting encodings</span>
<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name: Name of the layer</span>
<span class="sd">        :param activation_encodings_onnx: dictionary of activation encodings which maps onnx attribute to encodings</span>
<span class="sd">        :param activation_encodings_torch: dictionary of activation encodings which maps pytorch names to encodings</span>
<span class="sd">        :param param_encodings: dictionary of param encodings</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :param tensor_to_consumer_map: Dictionary mapping tensor names to op names which consume the tensor</span>
<span class="sd">        :param layers_to_onnx_op_names: Dictionary mapping PyTorch layer names to names of corresponding ONNX ops</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>

            <span class="c1"># --------------------------------------</span>
            <span class="c1"># Update encodings for Input activations</span>
            <span class="c1"># --------------------------------------</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dict_for_input_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                             <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                             <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                                                             <span class="n">layers_to_onnx_op_names</span><span class="p">,</span>
                                                                             <span class="n">tensor_to_quantizer_map</span><span class="p">)</span>
            <span class="c1"># ---------------------------------------</span>
            <span class="c1"># Update encodings for output activations</span>
            <span class="c1"># ---------------------------------------</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dict_for_output_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span>
                                                                              <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                              <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                              <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                                                              <span class="n">propagate_encodings</span><span class="p">,</span>
                                                                              <span class="n">tensor_to_consumer_map</span><span class="p">,</span>
                                                                              <span class="n">layers_to_onnx_op_names</span><span class="p">,</span>
                                                                              <span class="n">tensor_to_quantizer_map</span><span class="p">)</span>
            <span class="c1"># ---------------------------</span>
            <span class="c1"># Update encodings for Params</span>
            <span class="c1"># ---------------------------</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_param_encodings_dict_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">,</span>
                                                                        <span class="n">valid_param_set</span><span class="p">,</span> <span class="n">tensor_to_quantizer_map</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
            <span class="c1"># Update encodings for Recurrent layers</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dict_for_recurrent_layers</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                            <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                            <span class="n">param_encodings</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">,</span>
                                                                            <span class="n">tensor_to_quantizer_map</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">find_op_names_for_layer</span><span class="p">(</span><span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                <span class="n">tensor_to_consumer_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
                                <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the last ONNX op and the list of ONNX Ops that were mapped from a PyTorch Op.</span>

<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :param tensor_to_consumer_map: Dictionary mapping tensor names to op names which consume the tensor</span>
<span class="sd">        :param layers_to_onnx_op_names: Dictionary mapping PyTorch layer names to names of corresponding ONNX ops</span>
<span class="sd">        :return: tuple(end op names, all op names)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1.13.0&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">onnx_utils</span><span class="o">.</span><span class="n">EXPORT_TO_ONNX_DIRECT</span><span class="p">:</span>
            <span class="n">op_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">layer_name</span><span class="o">+</span><span class="s1">&#39;#&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="n">layer_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">op_names</span><span class="p">,</span> <span class="n">op_names</span>

            <span class="n">end_op_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">op_name</span> <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span> <span class="k">if</span> <span class="n">op_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.end&#39;</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">end_op_names</span><span class="p">,</span> <span class="n">op_names</span>

        <span class="k">assert</span> <span class="n">tensor_to_consumer_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">layers_to_onnx_op_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="c1"># Get all ops which correspond to the current PyTorch layer being processed.</span>
        <span class="n">op_names</span> <span class="o">=</span> <span class="n">layers_to_onnx_op_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">op_name_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">op_names</span><span class="p">)</span>

        <span class="n">end_op_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">end_op_names_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
            <span class="c1"># Loop through outputs of each op and check whether the output leads to an op not in</span>
            <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">tensor_to_consumer_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tensor_to_consumer_map</span><span class="p">[</span><span class="n">output</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">op_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">end_op_names_set</span><span class="p">:</span>
                        <span class="c1"># output has no consumers, and can either be a model output or an unused op output.</span>
                        <span class="c1"># List it as an end_op_name all the same.</span>
                        <span class="n">end_op_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
                        <span class="n">end_op_names_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">consumer</span> <span class="ow">in</span> <span class="n">tensor_to_consumer_map</span><span class="p">[</span><span class="n">output</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">consumer</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op_name_set</span> <span class="ow">and</span> <span class="n">op_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">end_op_names_set</span><span class="p">:</span>
                            <span class="n">end_op_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
                            <span class="n">end_op_names_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">end_op_names</span><span class="p">,</span> <span class="n">op_names</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dict_for_output_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                     <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                     <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">tensor_to_consumer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                                                     <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                                                     <span class="n">tensor_to_quantizer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="n">output_tensors</span><span class="p">,</span> <span class="n">propagate_tensors</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_layer_activation_tensors</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span>
                                                                                               <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                                               <span class="n">tensor_to_consumer_map</span><span class="p">,</span>
                                                                                               <span class="n">layers_to_onnx_op_names</span><span class="p">)</span>
        <span class="n">output_encodings</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">export_output_encodings</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_encodings</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;number of output quantizers: </span><span class="si">%d</span><span class="s2"> available for layer: </span><span class="si">%s</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;doesn&#39;t match with number of output tensors: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_encodings</span><span class="p">),</span> <span class="n">layer_name</span><span class="p">,</span>
                           <span class="nb">len</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">output_tensor</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">,</span> <span class="n">output_encodings</span><span class="p">)):</span>

            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">output_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>
                <span class="n">tensor_to_quantizer_map</span><span class="p">[</span><span class="n">output_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">QUANTIZER_TYPE_OUTPUT</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_OUTPUT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_OUTPUT</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">propagate_encodings</span><span class="p">:</span>
            <span class="n">valid_encodings</span> <span class="o">=</span> <span class="p">[</span><span class="n">enc</span> <span class="k">for</span> <span class="n">enc</span> <span class="ow">in</span> <span class="n">output_encodings</span> <span class="k">if</span> <span class="n">enc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">valid_encodings</span><span class="p">:</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="n">valid_encodings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">activation_tensor</span> <span class="ow">in</span> <span class="n">propagate_tensors</span><span class="p">:</span>
                    <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">activation_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_propagated_encoding_dict</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dict_for_input_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                    <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                    <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                                                    <span class="n">tensor_to_quantizer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
        <span class="n">input_encodings</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">export_input_encodings</span><span class="p">()</span>
        <span class="c1"># skip layer if it has no input encodings.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">input_encodings</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">input_tensors</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_layer_input_tensors</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                      <span class="n">layers_to_onnx_op_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_encodings</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;number of input quantizers: </span><span class="si">%d</span><span class="s2"> available for layer: </span><span class="si">%s</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;doesn&#39;t match with number of input tensors: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_encodings</span><span class="p">),</span> <span class="n">layer_name</span><span class="p">,</span>
                           <span class="nb">len</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">input_tensor</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">,</span> <span class="n">input_encodings</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">input_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>
                <span class="c1"># TODO: Modify this so quantsim does not make assumptions about the length of input_quantizers</span>
                <span class="n">tensor_to_quantizer_map</span><span class="p">[</span><span class="n">input_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="c1"># Check if layer exists in the pytorch encoding dictionary</span>
                <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">QUANTIZER_TYPE_INPUT</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># Store encodings for a particular index so that they can be used to check if a quantizer was</span>
                <span class="c1"># enabled or not</span>
                <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_layer_input_tensors</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                 <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the list of input tensor names mapped from a PyTorch Op.</span>

<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :param layers_to_onnx_op_names: Dictionary mapping PyTorch layer names to names of corresponding ONNX ops</span>
<span class="sd">        :return: list of input tensor names.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">param_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">param_name</span> <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">param_inputs</span><span class="p">):</span>
            <span class="n">param_inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">param_input</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;._module_to_wrap&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1.13.0&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">onnx_utils</span><span class="o">.</span><span class="n">EXPORT_TO_ONNX_DIRECT</span><span class="p">:</span>
            <span class="n">start_op_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span>
                              <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;#0&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">)</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="n">layer_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">layers_to_onnx_op_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">op_names</span> <span class="o">=</span> <span class="n">layers_to_onnx_op_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">onnx_op_outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">op_output</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                    <span class="n">onnx_op_outputs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_output</span><span class="p">)</span>

            <span class="n">start_op_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
                <span class="c1"># For each op&#39;s inputs, if the input comes from an op not associated with this layer, add it to</span>
                <span class="c1"># start_op_names.</span>
                <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">inp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">onnx_op_outputs</span> <span class="ow">and</span> <span class="n">inp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param_inputs</span><span class="p">:</span>
                        <span class="n">start_op_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>

        <span class="n">input_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">input_tensors_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">start_op_names</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">input_tensor</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">input_tensor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param_inputs</span> <span class="ow">and</span> <span class="n">input_tensor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_tensors_set</span><span class="p">:</span>
                    <span class="n">input_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>
                    <span class="n">input_tensors_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">input_tensors</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_layer_activation_tensors</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                      <span class="n">tensor_to_consumer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the list of output tensor and intermediate tensor names mapped from a PyTorch Op.</span>

<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :param tensor_to_consumer_map: Dictionary mapping tensor names to op names which consume the tensor</span>
<span class="sd">        :param layers_to_onnx_op_names: Dictionary mapping PyTorch layer names to names of corresponding ONNX ops</span>
<span class="sd">        :return: tuple containing list of output tensor names and list of intermediate tensors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">end_op_names</span><span class="p">,</span> <span class="n">op_names</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">find_op_names_for_layer</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span> <span class="n">tensor_to_consumer_map</span><span class="p">,</span>
                                                             <span class="n">layers_to_onnx_op_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output_op_map_str</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_output_map_str</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;layer_name: </span><span class="si">%s</span><span class="s2">, has multiple output onnx ops: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">output_op_map_str</span><span class="p">)</span>

        <span class="n">output_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">intermediate_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">end_op_names</span><span class="p">:</span>
                <span class="n">output_tensors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intermediate_tensors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output_tensors</span><span class="p">,</span> <span class="n">intermediate_tensors</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_output_map_str</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns formatted list of output ops tensor mapping</span>

<span class="sd">        :param end_op_names: list of output onnx ops</span>
<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :return: formatted string with output ops and their corresponding output count.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_output_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">)</span>
        <span class="n">op_map_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                               <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">end_op_names</span><span class="p">[:</span><span class="mi">5</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">num_output_ops</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">op_map_str</span> <span class="o">+=</span> <span class="s1">&#39;, ..&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">num_output_ops</span><span class="si">}</span><span class="s1">,[</span><span class="si">{</span><span class="n">op_map_str</span><span class="si">}</span><span class="s1">]&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dict_for_recurrent_layers</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                   <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                   <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">tensor_to_quantizer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param layer:</span>
<span class="sd">        :param layer_name:</span>
<span class="sd">        :param op_to_io_tensor_map:</span>
<span class="sd">        :param activation_encodings_onnx:</span>
<span class="sd">        :param param_encodings:</span>
<span class="sd">        :param propagate_encodings:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=too-many-nested-blocks</span>
        <span class="c1"># pylint: disable=too-many-locals</span>

        <span class="n">onnx_activations_to_quantizers</span><span class="p">,</span> <span class="n">onnx_params_to_quantizers</span> <span class="o">=</span> \
            <span class="n">layer</span><span class="o">.</span><span class="n">get_activation_param_quantizers_for_onnx_tensors</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">layer_name</span> <span class="o">+</span>
                                                                                       <span class="s1">&#39;#root_node&#39;</span><span class="p">])</span>
        <span class="c1"># ------------------</span>
        <span class="c1"># Activations</span>
        <span class="c1"># ------------------</span>
        <span class="n">quantizer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">onnx_activations_to_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span>
                                                                  <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>
            <span class="n">tensor_to_quantizer_map</span><span class="p">[</span><span class="n">tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantizer</span>

        <span class="k">if</span> <span class="n">propagate_encodings</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">op_names</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">find_op_names_for_layer</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
                <span class="n">io_tensor_list</span> <span class="o">=</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">io_tensor_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">io_tensor_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">io_tensor_list</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">io_tensors</span> <span class="ow">in</span> <span class="n">io_tensor_list</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">io_tensors</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">output_tensor</span> <span class="ow">in</span> <span class="n">io_tensors</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">output_tensor</span> <span class="ow">in</span> <span class="n">onnx_activations_to_quantizers</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
                            <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span>
                                                                                  <span class="kc">True</span><span class="p">)</span>

                            <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">output_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>
                            <span class="n">tensor_to_quantizer_map</span><span class="p">[</span><span class="n">output_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantizer</span>

        <span class="c1"># ------------------</span>
        <span class="c1"># Params</span>
        <span class="c1"># ------------------</span>
        <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">onnx_params_to_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span>
                                                                  <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">param_encodings</span><span class="p">[</span><span class="n">tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>
            <span class="n">tensor_to_quantizer_map</span><span class="p">[</span><span class="n">tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantizer</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_qc_quantized_layers</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">]]:</span>
        <span class="n">quantized_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">)):</span>
                <span class="n">quantized_layers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">module</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">quantized_layers</span>

    <span class="k">def</span> <span class="nf">_create_quantizer_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_to_quantize</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                 <span class="n">data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiates wrapper based on quant scheme</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="ow">in</span> <span class="p">[</span><span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                                      <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_enhanced_init</span><span class="p">,</span>
                                      <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_init</span><span class="p">,</span>
                                      <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span><span class="p">]</span>

        <span class="c1"># We lookup the number of input and output tensors already determined</span>
        <span class="c1"># Special case, we are adding a wrapper for a module not in the forward pass: Use default of 1, 1</span>
        <span class="n">num_in_tensors</span><span class="p">,</span> <span class="n">num_out_tensors</span> <span class="o">=</span> <span class="n">num_inout_tensors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Set quantizer to be a module replacer if it is in qc_quantize_modules_dict, otherwise set as</span>
        <span class="c1"># StaticGridQuantWrapper.</span>
        <span class="n">quantizer_wrapper_type</span> <span class="o">=</span> <span class="n">qc_quantize_modules_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">),</span> <span class="n">LazyQuantizeWrapper</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">quantizer_wrapper_type</span> <span class="o">==</span> <span class="n">LazyQuantizeWrapper</span><span class="p">:</span>
            <span class="n">quant_scheme_for_initialization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">quant_scheme_for_initialization</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_v1_quant_scheme_for_initialization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span><span class="p">)</span>

        <span class="c1"># TODO add quant_scheme_for_initialization for FP8 case</span>
        <span class="n">quantized_module</span> <span class="o">=</span> <span class="n">quantizer_wrapper_type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_param_bw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_rounding_mode</span><span class="p">,</span> <span class="n">quant_scheme_for_initialization</span><span class="p">,</span> <span class="n">num_inputs</span><span class="o">=</span><span class="n">num_in_tensors</span><span class="p">,</span>
                                                  <span class="n">num_outputs</span><span class="o">=</span><span class="n">num_out_tensors</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">quantized_module</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_is_quantizable_module</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">module</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
        <span class="c1"># pylint: disable=unidiomatic-typecheck</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="o">!=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span> <span class="ow">and</span>\
               <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">unquantizable_modules</span><span class="p">)</span> <span class="ow">and</span>\
               <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_quantized_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_is_quantized_module</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">module</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">quantized_modules</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_quantization_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursively add quantization wrappers to all appropriate modules starting with module</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_quantized_module</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;nn.Module found : </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">module_ref</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_quantizable_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">)</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="c1"># Create a new QcQuantize wrapper module</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_quantizer_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_quantization_wrappers</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_tensor_quantizers_for_consts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inout_tensor_shape_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify and set is_const for tensor quantizers which correspond to constant inputs in the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">qc_quantize_wrapper</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant_wrappers</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_wrapper</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">)):</span>
                    <span class="c1"># Only handling QcQuantWrappers and not QcQuantizeRecurrents</span>
                    <span class="c1"># pylint: disable=protected-access</span>
                    <span class="n">conn_graph_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="o">.</span><span class="n">_module_to_op_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">qc_quantize_wrapper</span><span class="o">.</span><span class="n">_module_to_wrap</span><span class="p">)</span>
                    <span class="n">input_tensor_shape_list</span> <span class="o">=</span> <span class="n">inout_tensor_shape_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">qc_quantize_wrapper</span><span class="o">.</span><span class="n">_module_to_wrap</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">conn_graph_op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">input_quantizer</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span> <span class="ow">in</span> \
                            <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">qc_quantize_wrapper</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">,</span> <span class="n">conn_graph_op</span><span class="o">.</span><span class="n">inputs</span><span class="p">)):</span>
                            <span class="n">input_quantizer</span><span class="o">.</span><span class="n">is_const</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">is_const</span>
                            <span class="n">input_quantizer</span><span class="o">.</span><span class="n">is_singleton</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_tensor_shape_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                                                            <span class="ow">and</span> <span class="n">input_tensor_shape_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                                                            <span class="ow">and</span> <span class="n">input_tensor_shape_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_encoding_dict</span><span class="p">(</span><span class="n">encoding</span><span class="p">:</span> <span class="n">libpymo</span><span class="o">.</span><span class="n">TfEncoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create encoding dictionary from encoding object</span>
<span class="sd">        :param encoding: Encoding of the quantizer</span>
<span class="sd">        :param quantizer: Tensor Quantizer</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :return: Encoding Dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">create_encoding_dict</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_remove_quantization_wrappers</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">starting_module</span><span class="p">,</span> <span class="n">list_of_modules_to_exclude</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively remove quantization wrappers from all appropriate modules starting with a given module</span>
<span class="sd">        :param starting_module: Module to recursive search downstream from</span>
<span class="sd">        :param list_of_modules_to_exclude: List of torch modules to remove quantization wrappers from (if present)</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">starting_module</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>

            <span class="c1"># If modules is in the exclude list, remove the wrapper</span>
            <span class="k">if</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">list_of_modules_to_exclude</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                    <span class="c1"># Remove the wrapper, gets auto-deleted</span>
                    <span class="c1"># pylint: disable=protected-access</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span><span class="o">.</span><span class="n">get_original_module</span><span class="p">())</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeStandAloneBase</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">())</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                    <span class="n">module_ref</span><span class="o">.</span><span class="n">update_params</span><span class="p">()</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span><span class="o">.</span><span class="n">module_to_quantize</span><span class="p">)</span>

            <span class="c1"># Recursively call children modules if present</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_remove_quantization_wrappers</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">list_of_modules_to_exclude</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_original_model</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">qdq_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the model with all quantization wrappers removed.</span>

<span class="sd">        :param model: The input model with quantization wrappers.</span>
<span class="sd">        :param qdq_weights: Whether to replace weights inside model by qdq weights.</span>
<span class="sd">        :return: Model without quantization wrappers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">original_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qdq_weights</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_apply_qdq_to_model_parameters</span><span class="p">(</span><span class="n">original_model</span><span class="p">)</span>
        <span class="c1"># pylint: disable=unnecessary-comprehension</span>
        <span class="n">all_modules_in_original_model</span> <span class="o">=</span> <span class="p">[</span><span class="n">module</span> <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">original_model</span><span class="o">.</span><span class="n">modules</span><span class="p">()]</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_remove_quantization_wrappers</span><span class="p">(</span><span class="n">original_model</span><span class="p">,</span> <span class="n">all_modules_in_original_model</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">original_model</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_apply_qdq_to_model_parameters</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies quant-dequant to the parameters of a PyTorch model</span>
<span class="sd">        to avoid rounding error during weight quantization.</span>

<span class="sd">        :param model: The PyTorch model whose parameters will be quant-dequantized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">StaticGridQuantWrapper</span><span class="p">)):</span>
                <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">_quantize_dequantize_params</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">LearnedGridQuantWrapper</span><span class="p">)):</span>
                <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">_quantize_params</span><span class="p">()</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_update_parameters_by_attr</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">_module_to_wrap</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_parameters_by_attr</span><span class="p">(</span><span class="n">module</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the internal parameters of a PyTorch module by its attributes</span>
<span class="sd">        and remove those attributes from module.__dict__ to avoid onnx export error.</span>

<span class="sd">        :param module: The PyTorch module whose parameters need to be updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">and</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
                <span class="n">module</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span>
                <span class="n">module</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_leaf_module_to_name_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a mapping from leaf modules to module name, where any ExportableQuantModule is considered a leaf module,</span>
<span class="sd">        and is therefore not further recursed (since we do not want to retrieve all internal quantizers/modules).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">recursively_populate_map</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_map</span><span class="p">,</span> <span class="n">start_str</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">starting_module</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">)</span> <span class="ow">or</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
                    <span class="n">module_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_str</span> <span class="o">+</span> <span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">recursively_populate_map</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">module_map</span><span class="p">,</span> <span class="n">start_str</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">module_to_name_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">recursively_populate_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">module_to_name_map</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">module_to_name_map</span>

    <span class="k">def</span> <span class="nf">_add_inputs_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">module_to_name_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_leaf_module_to_name_map</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">inputs_hook</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
            <span class="c1"># Need to remove hook here, otherwise the jit trace of CustomMarker with module ref will error since the</span>
            <span class="c1"># hook will be recursively hit.</span>
            <span class="n">hooks</span><span class="p">[</span><span class="n">module_ref</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">hooks</span><span class="p">[</span><span class="n">module_ref</span><span class="p">]</span>
            <span class="n">module_name</span> <span class="o">=</span> <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module_ref</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                <span class="n">module_ref</span> <span class="o">=</span> <span class="n">module_ref</span><span class="o">.</span><span class="n">get_original_module</span><span class="p">()</span>
            <span class="n">marker_layer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">CustomMarker</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="s1">&#39;True&#39;</span><span class="p">),</span>
                                           <span class="n">inputs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker_layer</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">module_to_name_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">hooks</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">inputs_hook</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_module_marker_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check to make sure all leaf modules have traced Custom Markers associated with them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_leaf_modules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_leaf_module_to_name_map</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">missing_inputs_entries</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">leaf_module</span> <span class="ow">in</span> <span class="n">all_leaf_modules</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leaf_module</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">missing_inputs_entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaf_module</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">missing_inputs_entries</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;In order to export a conditional model, all leaf modules need to be run with some input so &#39;</span>
                        <span class="s1">&#39;torch trace can be done.&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The following modules were not run during compute encodings:&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">missing_inputs_entries</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Please use the sim.run_modules_for_traced_custom_marker(&lt;module list&gt;, dummy_input) api to &#39;</span>
                        <span class="s1">&#39;pass dummy inputs to these modules.&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Modules which can take the same dummy input can be &#39;</span>
                        <span class="s1">&#39;grouped as a list. For groups of modules with different input shapes, please call &#39;</span>
                        <span class="s1">&#39;sim.run_modules_for_traced_custom_markers() for each group.&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exiting quantsim export early.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_export_conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                            <span class="n">forward_pass_callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">,</span>
                            <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">OnnxExportApiArgs</span><span class="p">(),</span>
                            <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export function for conditional models. Performs another round of forward passes to create and store traced</span>
<span class="sd">        CustomMarker info for each leaf module to be later used when scripting the model for export.</span>
<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph. It is required for the dummy_input to</span>
<span class="sd">                be placed on CPU.</span>
<span class="sd">        :param forward_pass_callback: A callback function that simply runs forward passes on the model. This callback</span>
<span class="sd">            function should use representative data for the forward pass, so the calculated encodings work for all</span>
<span class="sd">            data samples. This callback internally chooses the number of data samples it wants to use for calculating</span>
<span class="sd">            encodings. The callback should exercise all paths of the conditional model.</span>
<span class="sd">        :param forward_pass_callback_args: These argument(s) are passed to the forward_pass_callback as-is. Up to</span>
<span class="sd">            the user to determine the type of this parameter. E.g. could be simply an integer representing the number</span>
<span class="sd">            of data samples to use. Or could be a tuple of parameters or an object representing something more complex.</span>
<span class="sd">            If set to None, forward_pass_callback will be invoked with no parameters.</span>
<span class="sd">        :param onnx_export_args: onnx specific export arguments</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">onnx_export_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">onnx_export_args</span> <span class="o">=</span> <span class="n">OnnxExportApiArgs</span><span class="p">()</span>

        <span class="c1"># If model is conditional, we need to create traced CustomMarkers to be used later during export. Create hooks</span>
        <span class="c1"># here for creating a traced CustomMarker for each leaf module during the forward pass callback.</span>
        <span class="n">hooks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_inputs_hook</span><span class="p">(</span><span class="n">hooks</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">forward_pass_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">)</span>

        <span class="c1"># Any hooks that were hit during forward pass callback would have removed themselves. Remove the remaining</span>
        <span class="c1"># hooks that were not run.</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hooks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">h</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="c1"># Check that all paths were exercised</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_module_marker_map</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">configure_quantization_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                   <span class="n">default_data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantSimConfigurator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure inserted quantize ops using config file and fill in all the supported kernels</span>
<span class="sd">        :param config_file: Configuration file to use</span>
<span class="sd">        :param default_output_bw: default bitwidth for activations</span>
<span class="sd">        :param default_param_bw: default bitwidth for params</span>
<span class="sd">        :param default_data_type: default data type</span>
<span class="sd">        :return: QuantSimConfigurator object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;A connected graph failed to be built.</span><span class="se">\n</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;Unable to proceed with automatically configuring quantization ops using the config file.</span><span class="se">\n</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;Please configure quantization ops manually by redefining &#39;</span>
                         <span class="s1">&#39;QuantizationSimModel.configure_quantization_ops()&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">QuantSimConfigurator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="p">,</span> <span class="n">config_file</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">,</span>
                                    <span class="n">default_param_bw</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encodings</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">],</span>
                       <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="n">requires_grad</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">allow_overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param encodings: Encoding dictionary or path to the encoding dictionary json file.</span>
<span class="sd">        :param bool strict: If True, an error will be thrown if the model doesn&#39;t</span>
<span class="sd">            have a quantizer corresponding to the specified encodings.</span>
<span class="sd">        :param bool partial: If True, the encoding will be interpreted as a partial encoding,</span>
<span class="sd">            and the dangling quantizers with no corresponding encoding will be kept untouched.</span>
<span class="sd">            Otherwise, the dangling quantizers will be removed from the model.</span>
<span class="sd">        :param bool requires_grad: Whether or not the quantization parameters loaded from the</span>
<span class="sd">            encodings require gradient computation during training.</span>
<span class="sd">            If None, ``requires_grad`` flag of the quantization parameters will be kept unchanged.</span>
<span class="sd">        :param bool allow_overwrite: Whether or not the quantization parameters loaded from the</span>
<span class="sd">            encodings can be overwriiten by :ref:`compute_encodings` or another :ref:`load_encodings`.</span>
<span class="sd">            If None, whether the quantizer is overwrieable will be kept unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">encodings</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">)):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">encodings</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">encodings</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_load_encodings_impl</span><span class="p">(</span><span class="n">encodings</span><span class="p">,</span> <span class="n">strict</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">requires_grad</span><span class="p">,</span> <span class="n">allow_overwrite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_encodings_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encodings</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span>
                             <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                             <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                             <span class="n">requires_grad</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
                             <span class="n">allow_overwrite</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;param_encodings&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">encodings</span><span class="p">:</span>
            <span class="n">param_encodings</span> <span class="o">=</span> <span class="n">encodings</span>
            <span class="n">activation_encodings</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;An older AdaRound exported encoding file type has been detected! &quot;</span>
                           <span class="s2">&quot;Please regenerate it using the AdaRound export function from the latest &quot;</span>
                           <span class="s2">&quot;AIMET (version 1.32 or higher) if necessary. &quot;</span>
                           <span class="s2">&quot;Support for this encoding file will be deprecated in AIMET version 1.33.0.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_encodings</span> <span class="o">=</span> <span class="n">encodings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;param_encodings&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">activation_encodings</span> <span class="o">=</span> <span class="n">encodings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;activation_encodings&#39;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">param_encodings</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">activation_encodings</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>

        <span class="k">if</span> <span class="n">strict</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">encoding_keys</span> <span class="o">=</span> <span class="n">param_encodings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">|</span> <span class="n">activation_encodings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">model_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;._module_to_wrap&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span>
                             <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">(),</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_all_named_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)))</span>
            <span class="n">keys_not_found</span> <span class="o">=</span> <span class="n">encoding_keys</span> <span class="o">-</span> <span class="n">model_keys</span>
            <span class="k">if</span> <span class="n">keys_not_found</span><span class="p">:</span>
                <span class="n">keys_not_found</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">keys_not_found</span><span class="p">))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Encoding dictionary contains modules/parameters that doesn&#39;t exist in the model: </span><span class="si">{</span><span class="n">keys_not_found</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">param_encodings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_param_encodings</span><span class="p">(</span><span class="n">param_encodings</span><span class="p">,</span>
                                      <span class="n">strict</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">requires_grad</span><span class="p">,</span> <span class="n">allow_overwrite</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">activation_encodings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_activation_encodings</span><span class="p">(</span><span class="n">activation_encodings</span><span class="p">,</span>
                                           <span class="n">strict</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">requires_grad</span><span class="p">,</span> <span class="n">allow_overwrite</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Use </span><span class="si">{</span><span class="n">load_encodings</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">load_and_freeze_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ignore_when_quantizer_disabled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Functionality to set encodings (both activation and parameter) as per the given encodings JSON file and</span>
<span class="sd">        freeze them.</span>
<span class="sd">        .. note:</span>
<span class="sd">            The encodings JSON file should be the {prefix}_torch.encodings json exported during sim.export()</span>

<span class="sd">        :param encoding_path: JSON file path from where to load the encodings.</span>
<span class="sd">        :param ignore_when_quantizer_disabled: ignore raising RuntimeError while setting encodings,</span>
<span class="sd">            when quantizers are disabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_encodings</span><span class="p">(</span><span class="n">encoding_path</span><span class="p">,</span>
                            <span class="n">strict</span><span class="o">=</span><span class="ow">not</span> <span class="n">ignore_when_quantizer_disabled</span><span class="p">,</span>
                            <span class="n">partial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">allow_overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">encoding_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span>
                             <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                             <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                             <span class="n">requires_grad</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
                             <span class="n">allow_overwrite</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quant_module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quant_module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                <span class="n">param_encoding</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">param_name</span><span class="p">:</span> <span class="n">encoding_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">quant_module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">encoding_dict</span>
                <span class="p">}</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">quant_module</span><span class="o">.</span><span class="n">import_param_encodings</span><span class="p">(</span><span class="n">param_encoding</span><span class="p">,</span>
                                                        <span class="n">strict</span><span class="p">,</span>
                                                        <span class="n">partial</span><span class="p">,</span>
                                                        <span class="n">requires_grad</span><span class="p">,</span>
                                                        <span class="n">allow_overwrite</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Encoding import failed for module: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>


    <span class="k">def</span> <span class="nf">_set_activation_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">activation_encoding_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span>
                                  <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                  <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                  <span class="n">requires_grad</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
                                  <span class="n">allow_overwrite</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">input_encoding</span> <span class="o">=</span> <span class="n">activation_encoding_dict</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">input_encoding</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">module</span><span class="o">.</span><span class="n">import_input_encodings</span><span class="p">(</span><span class="n">input_encoding</span><span class="p">,</span>
                                              <span class="n">strict</span><span class="p">,</span>
                                              <span class="n">partial</span><span class="p">,</span>
                                              <span class="n">requires_grad</span><span class="p">,</span>
                                              <span class="n">allow_overwrite</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Encoding import failed for module: </span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">output_encoding</span> <span class="o">=</span> <span class="n">activation_encoding_dict</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">output_encoding</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">module</span><span class="o">.</span><span class="n">import_output_encodings</span><span class="p">(</span><span class="n">output_encoding</span><span class="p">,</span>
                                               <span class="n">strict</span><span class="p">,</span>
                                               <span class="n">partial</span><span class="p">,</span>
                                               <span class="n">requires_grad</span><span class="p">,</span>
                                               <span class="n">allow_overwrite</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Encoding import failed for module: </span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>


    <span class="nd">@deprecated</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Use </span><span class="si">{</span><span class="n">load_encodings</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_and_freeze_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set and freeze parameter encodings from encodings JSON file.</span>

<span class="sd">        :param encoding_path: path from where to load parameter encodings file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">encoding_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">encodings</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;activation_encodings&#39;</span> <span class="ow">in</span> <span class="n">encodings</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">encodings</span><span class="p">[</span><span class="s1">&#39;activation_encodings&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_encodings</span><span class="p">(</span><span class="n">encodings</span><span class="p">,</span>
                            <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">partial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">allow_overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">named_qmodules</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generator that yields all quantized modules in the model and their names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span>

    <span class="k">def</span> <span class="nf">qmodules</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generator that yields all quantized modules in the model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="p">(</span><span class="n">module</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_qmodules</span><span class="p">())</span>

    <span class="n">quant_wrappers</span> <span class="o">=</span> <span class="n">named_qmodules</span>

    <span class="k">def</span> <span class="nf">run_modules_for_traced_custom_marker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">],</span> <span class="n">dummy_input</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of modules to run and dummy input for the module, create a traced CustomMarker for each module</span>
<span class="sd">        and store it in the module_marker map. The same dummy input will be used for all modules.</span>

<span class="sd">        :param module_list: List of modules to create traced CustomMarkers for</span>
<span class="sd">        :param dummy_input: Dummy input for all modules</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">module_to_name_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_leaf_module_to_name_map</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">module_list</span><span class="p">:</span>
            <span class="c1"># Only perform init and trace if the given module is a leaf module, and we have not recorded it before</span>
            <span class="k">if</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">module_to_name_map</span> <span class="ow">and</span> <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">get_original_module</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">)</span> <span class="k">else</span> <span class="n">module</span>
                <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">module</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">marker_layer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">CustomMarker</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">dummy_input</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker_layer</span>

    <span class="k">def</span> <span class="nf">_validate_supported_kernels_for_quantizers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="n">SupportedKernelsAction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate supported kernels for all the Quantizers in the QuantSimModel</span>
<span class="sd">        :param action: The action to be performed when incorrect candidate is set in a quantizer</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">apply_act_param_rules</span><span class="p">(</span><span class="n">curr_candidate</span><span class="p">:</span> <span class="n">QuantDtypeBwInfo</span><span class="p">,</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QuantDtypeBwInfo</span><span class="p">],</span> <span class="n">module_name</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            helper function to validate both activation and param against the supported_kernels passed</span>
<span class="sd">            :param curr_candidate: candidate of interest</span>
<span class="sd">            :param allowed_supported_kernels: List of supported kernels for the given module</span>
<span class="sd">            :param module_name: name of the module</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">allow_error</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">curr_candidate</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">return</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">warn_on_error</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;candidate:</span><span class="si">%s</span><span class="s2"> is not under the supported_kernels for the module </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">curr_candidate</span><span class="p">,</span>
                                   <span class="n">module_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">assert_on_error</span><span class="p">:</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;candidate: </span><span class="si">{</span><span class="n">curr_candidate</span><span class="si">}</span><span class="s1"> is not under the supported_kernels for the module </span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">apply_act_rules</span><span class="p">(</span><span class="n">act</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">QuantizationDataType</span><span class="p">],</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QuantDtypeBwInfo</span><span class="p">],</span> <span class="n">module_name</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            helper function to validate both activation only against the supported_kernels passed</span>
<span class="sd">            :param act: act of the candidate to be validated</span>
<span class="sd">            :param allowed_supported_kernels: List of supported kernels for the given module</span>
<span class="sd">            :param module_name: name of the module</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">allow_error</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">is_same_activation</span><span class="p">(</span><span class="n">act</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">act</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">return</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">warn_on_error</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;activation:</span><span class="si">%s</span><span class="s2"> is not under the supported_kernels for the module </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span> <span class="n">module_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">assert_on_error</span><span class="p">:</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;activation: </span><span class="si">{</span><span class="n">act</span><span class="si">}</span><span class="s1"> is not under the supported_kernels for the module </span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

        <span class="c1"># retrieve all the act and param quantizer candidates, and validate them against supported_kernels</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">))</span> <span class="ow">and</span> <span class="n">module</span><span class="o">.</span><span class="n">supported_kernels</span><span class="p">:</span>
                <span class="n">supported_kernels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">supported_kernel</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">supported_kernels</span><span class="p">:</span>
                    <span class="c1"># ((activation bitwidth, activation data type), (param bitwidth, param data type))</span>
                    <span class="c1"># TODO modify this once reformat_supported_kernels generates of type QuantDtypeBwInfo</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="n">supported_kernels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">QuantDtypeBwInfo</span><span class="p">(</span><span class="n">supported_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">supported_kernels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">QuantDtypeBwInfo</span><span class="p">(</span><span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">act_candidates</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">param_candidate</span> <span class="o">=</span> <span class="p">()</span>
                <span class="k">for</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">input_quantizers</span> <span class="o">+</span> <span class="n">module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">:</span>
                    <span class="n">act_candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">quantizer</span><span class="o">.</span><span class="n">bitwidth</span><span class="p">,</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">data_type</span><span class="p">))</span>

                <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                    <span class="n">param_candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bitwidth</span><span class="p">,</span>
                                       <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">param_candidate</span><span class="p">:</span>
                    <span class="c1"># we need to check weights against all the activations</span>
                    <span class="k">for</span> <span class="n">act_candidate</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">act_candidates</span><span class="p">):</span>
                        <span class="n">apply_act_param_rules</span><span class="p">(</span><span class="n">QuantDtypeBwInfo</span><span class="p">(</span><span class="n">act_candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">act_candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param_candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                               <span class="n">param_candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">supported_kernels</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">act_candidates</span><span class="p">):</span>
                        <span class="n">apply_act_rules</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">supported_kernels</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_replace_quantization_wrapper_with_native_torch_quantization_nodes</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively remove quantization wrappers from all appropriate modules starting with a given module</span>
<span class="sd">        :param quant_sim_model: model for which QcQuantizeWrapper gets replaced with wrapped module using</span>
<span class="sd">        native torch quantization nodes</span>
<span class="sd">        :param device: device on which model is present</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Recursively replace quantization wrappers to native torch quantization nodes</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
            <span class="c1"># Create a native torch quantization node</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
                <span class="n">embedded_module</span> <span class="o">=</span> <span class="n">NativeTorchQuantWrapper</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="s1">&#39;_module_to_wrap&#39;</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">embedded_module</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Do not support save model embedded native torch quantization nodes using QcQuantizeRecurrent.&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span>

            <span class="c1"># Recursively call children modules if present</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_replace_quantization_wrapper_with_native_torch_quantization_nodes</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

    <span class="c1"># pylint: disable=protected-access, too-many-branches, too-many-locals</span>
    <span class="k">def</span> <span class="nf">_apply_exception_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply exception rules to specific op. For example, a rule can override high bitwidth to Embedding module</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">module_to_quant_wrapper</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant_wrappers</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">):</span>
                <span class="n">original_module</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">_module_to_wrap</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                <span class="n">original_module</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">module_to_quantize</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">module_to_quant_wrapper</span><span class="p">[</span><span class="n">original_module</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapper</span>

        <span class="k">for</span> <span class="n">original_module</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">module_to_quant_wrapper</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">original_module</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Embedding</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hw_version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;V73&#39;</span><span class="p">,</span> <span class="s1">&#39;V75&#39;</span><span class="p">,</span> <span class="s1">&#39;V79&#39;</span><span class="p">}:</span>
                    <span class="k">continue</span>
                <span class="n">weight_quantizer</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                <span class="n">output_quantizer</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">weight_quantizer</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">=</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">bitwidth</span>
                <span class="n">weight_quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span> <span class="o">=</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">original_module</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">GroupNorm</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hw_version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;V73&#39;</span><span class="p">,</span> <span class="s1">&#39;V75&#39;</span><span class="p">,</span> <span class="s1">&#39;V79&#39;</span><span class="p">}:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                    <span class="n">output_quantizer</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">param_quantizer</span> <span class="ow">in</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">param_quantizer</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">=</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">bitwidth</span>
                        <span class="n">param_quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span> <span class="o">=</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">original_module</span><span class="p">,</span> <span class="n">MatMul</span><span class="p">):</span>
                <span class="c1"># Skip unused modules</span>
                <span class="k">if</span> <span class="n">original_module</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="o">.</span><span class="n">_module_to_op_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">continue</span>

                <span class="n">first_input_quantizer</span><span class="p">,</span> <span class="n">second_input_quantizer</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">input_quantizers</span>

                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="o">.</span><span class="n">_module_to_op_dict</span><span class="p">[</span><span class="n">original_module</span><span class="p">]</span>
                <span class="n">first_input_op</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">producer</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">first_input_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">second_input_op</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">producer</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">second_input_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

                <span class="n">target_quantizer_for_first_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_target_quantizer</span><span class="p">(</span><span class="n">first_input_quantizer</span><span class="p">,</span> <span class="n">first_input_op</span><span class="p">,</span> <span class="n">module_to_quant_wrapper</span><span class="p">)</span>
                <span class="n">target_quantizer_for_second_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_target_quantizer</span><span class="p">(</span><span class="n">second_input_quantizer</span><span class="p">,</span> <span class="n">second_input_op</span><span class="p">,</span> <span class="n">module_to_quant_wrapper</span><span class="p">)</span>

                <span class="c1"># According to opdef for Matmul in HTP:</span>
                <span class="c1"># 16bit Weight(second input for dynamic MatMul) must have 16bit Activation(first input for dynamic MatMul).</span>
                <span class="c1"># 16bit Activation and 16bit Weight require minimum arch V73.</span>
                <span class="c1"># 16bit Weight must be symmetric quantized.</span>

                <span class="c1"># Below are the possible combinations for MatMul with 8/16 bitwidth:</span>
                <span class="c1"># If version is V73 and higher: {input0-&gt;8, input1-&gt;8 symm/asymm} {input0-&gt;16 , input1-&gt;8 symm/asymm} {input0-&gt;16, input1-&gt;16 symmetric}</span>
                <span class="c1"># If version is lesser than V73: {input0-&gt;8, input1-&gt;8 symmetric} {input0-&gt;16, input1-&gt;8 symmetric}</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hw_version</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;V66&#39;</span><span class="p">,</span> <span class="s1">&#39;V68&#39;</span><span class="p">,</span> <span class="s1">&#39;V69&#39;</span><span class="p">}:</span>
                    <span class="k">if</span> <span class="n">target_quantizer_for_second_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The target quantizer for second input could not be found. MatMul exception rule does not apply for layer: </span><span class="si">%s</span><span class="s2">. &quot;</span>
                                       <span class="s2">&quot;If you haven&#39;t used model preparer, consider using it.&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">original_module</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">target_quantizer_for_second_input</span><span class="o">.</span><span class="n">use_symmetric_encodings</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">target_quantizer_for_second_input</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">=</span> <span class="mi">8</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hw_version</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;V73&#39;</span><span class="p">,</span> <span class="s1">&#39;V75&#39;</span><span class="p">,</span> <span class="s1">&#39;V79&#39;</span><span class="p">}:</span>
                    <span class="k">if</span> <span class="n">target_quantizer_for_first_input</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">target_quantizer_for_second_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The target quantizers could not be found. MatMul exception rule does not apply for layer: </span><span class="si">%s</span><span class="s2">. &quot;</span>
                                       <span class="s2">&quot;If you haven&#39;t used model preparer, consider using it.&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">original_module</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">target_quantizer_for_second_input</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
                        <span class="n">target_quantizer_for_second_input</span><span class="o">.</span><span class="n">use_symmetric_encodings</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">target_quantizer_for_first_input</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">=</span> <span class="mi">16</span>

    <span class="k">def</span> <span class="nf">_get_target_quantizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_quantizer</span><span class="p">:</span> <span class="n">TensorQuantizer</span><span class="p">,</span> <span class="n">input_op</span><span class="p">:</span> <span class="n">Op</span><span class="p">,</span> <span class="n">module_to_quant_wrapper</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TensorQuantizer</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns input quantizer if enabled otherwise returns closest enabled parent output quantizer.</span>

<span class="sd">        :param input_quantizer: Input quantizer</span>
<span class="sd">        :param input_op: Input Op</span>
<span class="sd">        :param module_to_quant_wrapper: Dict of module to quant wrapper</span>
<span class="sd">        :return: Target quantizer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_quantizer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="n">target_quantizer</span> <span class="o">=</span> <span class="n">input_quantizer</span>
        <span class="k">elif</span> <span class="n">input_op</span><span class="p">:</span>
            <span class="n">closest_producer_wrapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_closest_producer_wrapper</span><span class="p">(</span>
                <span class="n">input_op</span><span class="p">,</span> <span class="n">module_to_quant_wrapper</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">closest_producer_wrapper</span><span class="p">:</span>
                <span class="n">target_quantizer</span> <span class="o">=</span> <span class="n">closest_producer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> \
                        <span class="k">if</span> <span class="n">closest_producer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">closest_producer_wrapper</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The closest wrapper could not be found. MatMul exception rule does not apply. &quot;</span>
                               <span class="s2">&quot;If you haven&#39;t used model preparer, consider using it.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target_quantizer</span>


    <span class="k">def</span> <span class="nf">_get_closest_producer_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                      <span class="n">op</span><span class="p">:</span> <span class="n">Op</span><span class="p">,</span>
                                      <span class="n">module_to_quant_wrapper</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">])</span> <span class="o">-&gt;</span> \
            <span class="n">Optional</span><span class="p">[</span><span class="n">QcQuantizeWrapper</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the closest producer QcQuantizeWrapper and return it</span>

<span class="sd">        :param op: Target operation</span>
<span class="sd">        :param module_to_quant_wrapper: Module to Wrapper dictionary</span>
<span class="sd">        :return: QcQuantizerWrapper if exists else None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_quant_wrapper</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">QcQuantizeWrapper</span><span class="p">]:</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">get_module</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">module_to_quant_wrapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="k">if</span> <span class="n">module</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">wrapper</span> <span class="o">=</span> <span class="n">get_quant_wrapper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">wrapper</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">or</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">wrapper</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">input_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_closest_producer_wrapper</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">input_ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">module_to_quant_wrapper</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;A wrapper of </span><span class="si">%s</span><span class="s2"> with output quantization disabled has no input or more than one input &quot;</span>
                           <span class="s2">&quot;exists. It&#39;s ambiguous to find the nearest producer in this case&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">get_module</span><span class="p">()))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">input_ops</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No input exists for navigation for traversal, it&#39;s not possible to find the closest producer&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">input_ops</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Multiple input ops exist, traversal to find closest producer is performed based on the &quot;</span>
                           <span class="s2">&quot;first input&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_closest_producer_wrapper</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">input_ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">module_to_quant_wrapper</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">save_model_with_embedded_quantization_nodes</span><span class="p">(</span><span class="n">sim_model</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                                                    <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                    <span class="n">export_to_torchscript</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">is_conditional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export model embedded with native torch quantization nodes. These nodes will be exported</span>
<span class="sd">        as default onnx or torch script quantized nodes.</span>
<span class="sd">        :param sim_model: model with the quantsim wrappers</span>
<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph</span>
<span class="sd">        :param onnx_export_args: optional export argument with onnx specific overrides if not provide export via</span>
<span class="sd">                torchscript graph. Int16 can only be exported by torchscript</span>
<span class="sd">        :param export_to_torchscript: If True, export to torchscript. Export to onnx otherwise. Defaults to False.</span>
<span class="sd">        :param is_conditional: True if model is conditional, False otherwise</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_validate_torchquantizer</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">):</span>
            <span class="c1"># To avoid non 8 bit TorchQuantizer are exported to ONNX</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">NativeTorchQuantWrapper</span><span class="p">):</span>
                    <span class="n">quantizers</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">input_quantizers</span> <span class="o">+</span> <span class="n">module</span><span class="o">.</span><span class="n">output_quantizers</span>
                    <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                        <span class="n">quantizers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="s1">&#39;bias&#39;</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                        <span class="n">quantizers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">]]</span>

                    <span class="k">for</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">quantizers</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only 8 bit quantizers are supported by exporting to ONNX model.&#39;</span>
                                             <span class="s1">&#39;Please enable export_to_torchscript if you want to export non 8 bit quantizers.&#39;</span><span class="p">)</span>

        <span class="n">model_filename</span> <span class="o">=</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;_embedded&#39;</span> <span class="o">+</span> <span class="s1">&#39;.onnx&#39;</span>
        <span class="n">model_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">model_filename</span><span class="p">)</span>
        <span class="n">quant_sim_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sim_model</span><span class="p">)</span>

        <span class="n">device</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dummy_input</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">dummy_input</span> <span class="o">=</span> <span class="n">dummy_input</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dummy_input</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">input</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">dummy_input</span><span class="p">])</span>  <span class="c1"># pylint: disable=consider-using-generator</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_replace_quantization_wrapper_with_native_torch_quantization_nodes</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">export_to_torchscript</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>
                <span class="n">ts_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;_embedded&#39;</span> <span class="o">+</span> <span class="s1">&#39;.torchscript.pth&#39;</span><span class="p">)</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">ts_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_validate_torchquantizer</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">)</span>
            <span class="n">OnnxSaver</span><span class="o">.</span><span class="n">_export_model_to_onnx</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span> <span class="n">model_path</span><span class="p">,</span> <span class="n">is_conditional</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">)</span> <span class="c1"># pylint: disable=protected-access</span>

    <span class="k">def</span> <span class="nf">_enable_output_quantizers_for_specific_cast_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inout_tensors_dtypes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable output quantizer for Cast Ops where datatype of input tensor is int/bool</span>
<span class="sd">        and data type of output tensor is float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">model_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="o">.</span><span class="n">_model_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
        <span class="n">torch_int_dtypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">torch</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">}</span>
        <span class="n">torch_float_dtypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">torch</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">module</span><span class="p">,</span> <span class="n">inout_dtypes</span> <span class="ow">in</span> <span class="n">inout_tensors_dtypes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">input_tensor_dtype</span> <span class="o">=</span> <span class="n">inout_dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">output_tensor_dtype</span> <span class="o">=</span> <span class="n">inout_dtypes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># pylint: disable=protected-access</span>
            <span class="n">module_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="o">.</span><span class="n">_module_to_name</span><span class="p">[</span><span class="n">module</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">model_prefix</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">input_tensor_dtype</span> <span class="o">!=</span> <span class="n">output_tensor_dtype</span> <span class="ow">and</span> <span class="n">input_tensor_dtype</span> <span class="ow">in</span> <span class="n">torch_int_dtypes</span> <span class="ow">and</span> <span class="n">output_tensor_dtype</span> <span class="ow">in</span> <span class="n">torch_float_dtypes</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Enabling output quantizer for module </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">module_name</span><span class="p">)</span>
                <span class="n">wrapped_module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">module_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">output_quantizer</span> <span class="ow">in</span> <span class="n">wrapped_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">output_quantizer</span><span class="p">,</span> <span class="s1">&#39;enabled&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_num_inout_tensors_from_tensor_shape_dict</span><span class="p">(</span><span class="n">inout_tensor_shape_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert tensor shape dictionary to num inout tensors dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_inout_tensors</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">module</span><span class="p">,</span> <span class="n">inout_tensor_shape</span> <span class="ow">in</span> <span class="n">inout_tensor_shape_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">input_tensor_shape_list</span><span class="p">,</span> <span class="n">output_tensor_shape_list</span> <span class="o">=</span> <span class="n">inout_tensor_shape</span>
            <span class="n">num_inout_tensors</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_tensor_shape_list</span><span class="p">),</span>
                                         <span class="nb">len</span><span class="p">(</span><span class="n">output_tensor_shape_list</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">num_inout_tensors</span></div>


<span class="k">def</span> <span class="nf">save_checkpoint</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">:</span> <span class="n">QuantizationSimModel</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This API provides a way for the user to save a checkpoint of the quantized model which can</span>
<span class="sd">    be loaded at a later point to continue fine-tuning e.g.</span>
<span class="sd">    See also load_checkpoint()</span>

<span class="sd">    :param quant_sim_model: QuantizationSimModel to save checkpoint for</span>
<span class="sd">    :param file_path: Path to the file where you want to save the checkpoint</span>
<span class="sd">    :return: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load_checkpoint</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantizationSimModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the quantized model</span>

<span class="sd">    :param file_path: Path to the file where you want to save the checkpoint</span>
<span class="sd">    :return: A new instance of the QuantizationSimModel created after loading the checkpoint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sim</span>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;check_accumulator_overflow API will be removed in the future releases.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">check_accumulator_overflow</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">quant_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">accum_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks for any potential for accumulator overflow across all the layers of the given model</span>
<span class="sd">    :param model: Model</span>
<span class="sd">    :param quant_bw: Bitwidth the layers are quantized at</span>
<span class="sd">    :param accum_bw: Bitwidth of the accumulator</span>
<span class="sd">    :return: Name of the layer with the most accumulator range used and range used</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">most_accum_range_used</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">most_accum_range_used_layer</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">):</span>
            <span class="n">was_accum_range_exceeded</span><span class="p">,</span> <span class="n">accum_range_used</span> <span class="o">=</span> <span class="n">get_conv_accum_bounds</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                                                                               <span class="n">quant_bw</span><span class="p">,</span> <span class="n">accum_bw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">accum_range_used</span> <span class="o">&gt;</span> <span class="n">most_accum_range_used</span><span class="p">:</span>
                <span class="n">most_accum_range_used</span> <span class="o">=</span> <span class="n">accum_range_used</span>
                <span class="n">most_accum_range_used_layer</span> <span class="o">=</span> <span class="n">layer_name</span>

            <span class="k">if</span> <span class="n">was_accum_range_exceeded</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Possible accumulator overflow for layer: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">most_accum_range_used</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No overflow detected. Layer </span><span class="si">%s</span><span class="s1"> had the most accumulator range used: </span><span class="si">%f%%</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">most_accum_range_used_layer</span><span class="p">,</span> <span class="n">most_accum_range_used</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Overflow detected. Layer </span><span class="si">%s</span><span class="s1"> had the most accumulator range used: </span><span class="si">%f%%</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">most_accum_range_used_layer</span><span class="p">,</span> <span class="n">most_accum_range_used</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">most_accum_range_used_layer</span><span class="p">,</span> <span class="n">most_accum_range_used</span>


<span class="nd">@deprecated</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Use </span><span class="si">{</span><span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">load_encodings</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">load_encodings_to_sim</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">:</span> <span class="n">QuantizationSimModel</span><span class="p">,</span> <span class="n">pytorch_encoding_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads the saved encodings to quant sim model. The encoding filename to load should end in _torch.encodings,</span>
<span class="sd">    generated as part of quantsim export.</span>

<span class="sd">    :param quant_sim_model: Quantized model to load encodings for. Note: The model configuration should be the same as</span>
<span class="sd">        when encodings were exported.</span>
<span class="sd">    :param pytorch_encoding_path: Path of the encodings file to load.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
            <span class="n">module</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">)</span>

    <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">load_encodings</span><span class="p">(</span><span class="n">pytorch_encoding_path</span><span class="p">,</span>
                                   <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">requires_grad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">allow_overwrite</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">QuantizationSimModel</span><span class="p">):</span>
        <span class="c1"># Only for V1 quantsim</span>
        <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">replace_wrappers_for_quantize_dequantize</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">has_valid_encodings</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility for determining whether a given qc_quantize_op has any valid encodings.</span>

<span class="sd">    :param qc_quantize_op: Qc quantize op to evaluate</span>
<span class="sd">    :return: True if any input, param, or output quantizers have valid encodings, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">,</span> <span class="p">(</span><span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">)):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;has_valid_encodings only supported for QcQuantizeWrapper and QcQuantizeRecurrent &quot;</span>
                     <span class="s2">&quot;modules&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">,</span> <span class="p">(</span><span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
        <span class="n">all_encodings</span> <span class="o">=</span> <span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">export_output_encodings</span><span class="p">()</span> <span class="o">+</span> <span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">export_input_encodings</span><span class="p">()</span> <span class="o">+</span> \
                        <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">export_param_encodings</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">all_encodings</span><span class="p">])</span>  <span class="c1"># pylint: disable=consider-using-generator,use-a-generator</span>
    <span class="n">input_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">output_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">input_quantizers</span> <span class="o">+</span> <span class="n">output_quantizers</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> <span class="p">(</span><span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">data_type</span> <span class="ow">is</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">compute_encodings_for_sims</span><span class="p">(</span><span class="n">sim_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QuantizationSimModel</span><span class="p">],</span> <span class="n">forward_pass_callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                               <span class="n">forward_pass_callback_args</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute encodings for a list of QuantSims.</span>

<span class="sd">    :param sim_list: List of QuantSims to compute encodings for.</span>
<span class="sd">    :param forward_pass_callback: A callback function that simply runs forward passes on the models. This callback</span>
<span class="sd">        function should use representative data for the forward pass, so the calculated encodings work for all</span>
<span class="sd">        data samples. This callback internally chooses the number of data samples it wants to use for calculating</span>
<span class="sd">        encodings.</span>
<span class="sd">        The callback expects exactly two inputs:</span>
<span class="sd">            - List of models which are involved in the forward pass. The models are taken directly from calling</span>
<span class="sd">            sim.model for each sim in sim_list, passed in the same order in which the sims appear in sim_list.</span>
<span class="sd">            - Forward pass callback args</span>
<span class="sd">    :param forward_pass_callback_args: These argument(s) are passed to the forward_pass_callback as-is. Up to</span>
<span class="sd">        the user to determine the type of this parameter. E.g. could be simply an integer representing the number</span>
<span class="sd">        of data samples to use. Or could be a tuple of parameters or an object representing something more complex.</span>
<span class="sd">        If set to None, forward_pass_callback will be invoked with no parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx_managers</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">sim_list</span><span class="p">:</span>
        <span class="n">ctx_managers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">model</span><span class="p">))</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">prepare_sim_for_compute_encodings</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">mgr</span> <span class="ow">in</span> <span class="n">ctx_managers</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">forward_pass_callback</span><span class="p">([</span><span class="n">sim</span><span class="o">.</span><span class="n">model</span> <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">sim_list</span><span class="p">],</span> <span class="n">forward_pass_callback_args</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">sim_list</span><span class="p">:</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">compute_layer_encodings_for_sim</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Qualcomm Innovation Center, Inc..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>