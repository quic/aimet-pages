<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aimet_torch.quantsim &mdash; AI Model Efficiency Toolkit Documentation: ver 1.32.0</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css" />
      <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

    
    
    <a href="../../user_guide/index.html" class="icon icon-home">
    AI Model Efficiency Toolkit
      <img src="../../_static/brain_logo.png" class="logo" alt="Logo"/>
    </a>
      <div class="version">
        1.32.0
      </div>

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="Versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      AIMET Variant: <span class="rst-current-version-name"> Universal </span>
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Documentation Versions</dt>
        
          <dd><a href="https://quic.github.io/aimet-pages/releases/latest/user_guide/index.html">Universal</a></dd>
        
          <dd><a href="https://quic.github.io/aimet-pages/releases/latest/torch_v2/torch_docs/index.html">PyTorch</a></dd>
        
      </dl>
    </div>
  </div>

<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/model_quantization.html"> Quantization User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_quantization.html#use-cases">Use Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_quantization.html#aimet-quantization-features">AIMET Quantization Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/quantization_sim.html"> Quantization Simulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_sim.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_sim.html#quantsim-workflow">QuantSim Workflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_sim.html#simulating-quantization-noise">Simulating Quantization Noise</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_sim.html#determining-quantization-parameters-encodings">Determining Quantization Parameters (Encodings)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_sim.html#quantization-schemes">Quantization Schemes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_sim.html#configuring-quantization-simulation-ops">Configuring Quantization Simulation Ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_sim.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/quantization_aware_training.html"> Quantization-Aware Training (QAT)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_aware_training.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_aware_training.html#qat-workflow">QAT workflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_aware_training.html#qat-modes">QAT modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quantization_aware_training.html#recommendations-for-quantization-aware-training">Recommendations for Quantization-Aware Training</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/model_quantization.html#post-training-quantization"><span class="hideitem">Post-Training Quantization</span></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/auto_quant.html">AutoQuant</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/auto_quant.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/auto_quant.html#workflow">Workflow</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/adaround.html">Adaptive Rounding (AdaRound)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/adaround.html#adaround-use-cases">AdaRound Use Cases</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/adaround.html#common-terminology">Common terminology</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/adaround.html#use-cases">Use Cases</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html">Cross-Layer Equalization</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html#user-flow">User Flow</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html#faqs">FAQs</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/bn_reestimation.html">BN Re-estimation</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/bn_reestimation.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/bn_reestimation.html#workflow">Workflow</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html">Bias Correction [Depricated]</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html#user-flow">User Flow</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html#faqs">FAQs</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/post_training_quant_techniques.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/model_quantization.html#debugging-analysis-tools"><span class="hideitem">Debugging/Analysis Tools</span></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/quant_analyzer.html">QuantAnalyzer</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/quant_analyzer.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/quant_analyzer.html#requirements">Requirements</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/quant_analyzer.html#detailed-analysis-descriptions">Detailed Analysis Descriptions</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_quant.html">Visualizations</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/visualization_quant.html#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/visualization_quant.html#quantization">Quantization</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../user_guide/visualization_quant.html#pytorch">PyTorch</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../user_guide/visualization_quant.html#tensorflow">TensorFlow</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_quantization.html#aimet-quantization-workflow">AIMET Quantization Workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/model_quantization.html#pytorch"><span class="hideitem">PyTorch</span></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_model_guidelines.html"> PyTorch Model Guidelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_quantization.html"> AIMET PyTorch Quantization APIs</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_model_guidelines.html"> Model Guidelines</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_architecture_checker.html"> Architecture Checker API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_architecture_checker.html#aimet_torch.arch_checker.arch_checker.ArchChecker.check_model_arch"><code class="docutils literal notranslate"><span class="pre">check_model_arch()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_model_preparer.html"> Model Preparer API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_model_preparer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_model_preparer.html#aimet_torch.model_preparer.prepare_model"><code class="docutils literal notranslate"><span class="pre">prepare_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_model_preparer.html#code-examples">Code Examples</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_model_preparer.html#limitations-of-torch-fx-symbolic-trace-api">Limitations of torch.fx symbolic trace API</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_model_validator.html"> Model Validator API</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html"> Quant Analyzer API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#aimet_torch.quant_analyzer.QuantAnalyzer"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer</span></code></a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#aimet_torch.quant_analyzer.QuantAnalyzer.analyze"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.analyze()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#aimet_torch.quant_analyzer.QuantAnalyzer.enable_per_layer_mse_loss"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.enable_per_layer_mse_loss()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quantsim.html"> Quantization Simulation API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#guidelines">Guidelines</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel</span></code></a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel.compute_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.compute_encodings()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel.export"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.export()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.save_checkpoint"><code class="docutils literal notranslate"><span class="pre">quantsim.save_checkpoint()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.load_checkpoint"><code class="docutils literal notranslate"><span class="pre">quantsim.load_checkpoint()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme"><code class="docutils literal notranslate"><span class="pre">QuantScheme</span></code></a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.post_training_percentile"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_percentile</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.post_training_tf"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.post_training_tf_enhanced"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf_enhanced</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_enhanced_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_enhanced_init</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_init</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#code-example-quantization-aware-training-qat">Code Example - Quantization Aware Training (QAT)</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_adaround.html"> Adaptive Rounding API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_adaround.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_adaround.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_adaround.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_torch.adaround.adaround_weight.Adaround.apply_adaround"><code class="docutils literal notranslate"><span class="pre">apply_adaround()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_adaround.html#adaround-parameters">Adaround Parameters</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_torch.adaround.adaround_weight.AdaroundParameters"><code class="docutils literal notranslate"><span class="pre">AdaroundParameters</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_adaround.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme"><code class="docutils literal notranslate"><span class="pre">QuantScheme</span></code></a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.post_training_percentile"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_percentile</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.post_training_tf"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.post_training_tf_enhanced"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf_enhanced</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_enhanced_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_enhanced_init</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_init</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_adaround.html#code-example-adaptive-rounding-adaround">Code Example - Adaptive Rounding (AdaRound)</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html"> Cross-Layer Equalization API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#introduction">Introduction</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#cross-layer-equalization-api">Cross Layer Equalization API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#aimet_torch.cross_layer_equalization.equalize_model"><code class="docutils literal notranslate"><span class="pre">equalize_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#code-example">Code Example</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#primitive-apis">Primitive APIs</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html">Primitive APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#introduction">Introduction</a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#clssetinfo-definition">ClsSetInfo Definition</a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.ClsSetInfo"><code class="docutils literal notranslate"><span class="pre">ClsSetInfo</span></code></a><ul>
<li class="toctree-l10"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.ClsSetInfo.ClsSetLayerPairInfo"><code class="docutils literal notranslate"><span class="pre">ClsSetInfo.ClsSetLayerPairInfo</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#higher-level-apis-for-cross-layer-equalization">Higher Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.batch_norm_fold.fold_all_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.CrossLayerScaling.scale_model"><code class="docutils literal notranslate"><span class="pre">scale_model()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.HighBiasFold.bias_fold"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#code-examples-for-higher-level-apis">Code Examples for Higher Level APIs</a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#lower-level-apis-for-cross-layer-equalization">Lower Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.batch_norm_fold.fold_given_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_given_batch_norms()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.CrossLayerScaling.scale_cls_sets"><code class="docutils literal notranslate"><span class="pre">scale_cls_sets()</span></code></a></li>
<li class="toctree-l9"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#id0"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#code-examples-for-lower-level-apis">Code Examples for Lower Level APIs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_bias_correction.html"> Bias Correction API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#bias-correction-api">Bias Correction API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_torch.bias_correction.correct_bias"><code class="docutils literal notranslate"><span class="pre">correct_bias()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#convbninfotype">ConvBnInfoType</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.bias_correction.ConvBnInfoType"><code class="docutils literal notranslate"><span class="pre">ConvBnInfoType</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#activationtype">ActivationType</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType"><code class="docutils literal notranslate"><span class="pre">ActivationType</span></code></a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType.no_activation"><code class="docutils literal notranslate"><span class="pre">ActivationType.no_activation</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType.relu"><code class="docutils literal notranslate"><span class="pre">ActivationType.relu</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType.relu6"><code class="docutils literal notranslate"><span class="pre">ActivationType.relu6</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#quantization-params">Quantization Params</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_torch.quantsim.QuantParams"><code class="docutils literal notranslate"><span class="pre">QuantParams</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#code-example-1-empirical-bias-correction">Code Example #1 Empirical Bias Correction</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#code-example-2-analytical-empirical-bias-correction">Code Example #2 Analytical + Empirical Bias correction</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_auto_quant.html"> AutoQuant API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant"><code class="docutils literal notranslate"><span class="pre">AutoQuant</span></code></a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.run_inference"><code class="docutils literal notranslate"><span class="pre">AutoQuant.run_inference()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.optimize"><code class="docutils literal notranslate"><span class="pre">AutoQuant.optimize()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.set_adaround_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_adaround_params()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.set_export_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_export_params()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.set_model_preparer_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_model_preparer_params()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.get_quant_scheme_candidates"><code class="docutils literal notranslate"><span class="pre">AutoQuant.get_quant_scheme_candidates()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.set_quant_scheme_candidates"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_quant_scheme_candidates()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant.AutoQuant"><code class="docutils literal notranslate"><span class="pre">AutoQuant</span></code></a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant.AutoQuant.apply"><code class="docutils literal notranslate"><span class="pre">AutoQuant.apply()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant.AutoQuant.set_adaround_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_adaround_params()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant.AutoQuant.set_export_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_export_params()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html"> BN Re-estimation APIs</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#introduction">Introduction</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#top-level-apis">Top-level APIs</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#aimet_torch.bn_reestimation.reestimate_bn_stats"><code class="docutils literal notranslate"><span class="pre">reestimate_bn_stats()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#aimet_torch.batch_norm_fold.fold_all_batch_norms_to_scale"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms_to_scale()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#code-example-bn-reestimation">Code Example - BN-Reestimation</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_multi_gpu.html"> Multi-GPU guidelines</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/model_quantization.html#tensorflow"><span class="hideitem">Tensorflow</span></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_model_guidelines.html"> TensorFlow Model Guidelines</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_model_guidelines.html#aimet_tensorflow.utils.graph.update_keras_bn_ops_trainable_flag"><code class="docutils literal notranslate"><span class="pre">update_keras_bn_ops_trainable_flag()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_quantization.html#debugging-guidelines">Debugging Guidelines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/quantization_feature_guidebook.html">Quantization Guidebook</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/model_compression.html"> Compression User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/compression_feature_guidebook.html">Compression Guidebook</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#use-case">Use Case</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#compression-ratio-selection">Compression ratio selection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/greedy_compression_ratio_selection.html">Greedy Compression Ratio Selection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/greedy_compression_ratio_selection.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/greedy_compression_ratio_selection.html#how-it-works">How it works</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/greedy_compression_ratio_selection.html#per-layer-exploration">Per-layer Exploration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/greedy_compression_ratio_selection.html#compression-ratio-selection">Compression Ratio Selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/visualization_compression.html">Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#design">Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#compression">Compression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#starting-a-bokeh-server-session">Starting a Bokeh Server Session:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#how-to-use-the-tool">How to use the tool</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#model-compression">Model Compression</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/weight_svd.html">Weight SVD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/spatial_svd.html">Spatial SVD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/channel_pruning.html">Channel Pruning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/channel_pruning.html#overall-procedure">Overall Procedure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/channel_pruning.html#channel-selection">Channel Selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/channel_pruning.html#winnowing">Winnowing</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../user_guide/winnowing.html">Winnowing</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../user_guide/winnowing.html#overview">Overview</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../user_guide/winnowing.html#winnowing-overview">Winnowing Overview</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../user_guide/winnowing.html#how-winnowing-works">How Winnowing Works</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/channel_pruning.html#weight-reconstruction">Weight Reconstruction</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#optional-techniques-to-get-better-compression-results">Optional techniques to get better compression results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/model_compression.html#rank-rounding">Rank Rounding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/model_compression.html#per-layer-fine-tuning">Per-layer Fine-tuning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#faqs">FAQs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api_docs/index.html"> API Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api_docs/torch.html">AIMET APIs for PyTorch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/torch_quantization.html">PyTorch Model Quantization API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_model_guidelines.html"> Model Guidelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_architecture_checker.html"> Architecture Checker API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_architecture_checker.html#aimet_torch.arch_checker.arch_checker.ArchChecker.check_model_arch"><code class="docutils literal notranslate"><span class="pre">check_model_arch()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_model_preparer.html"> Model Preparer API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_model_preparer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_model_preparer.html#aimet_torch.model_preparer.prepare_model"><code class="docutils literal notranslate"><span class="pre">prepare_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_model_preparer.html#code-examples">Code Examples</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_model_preparer.html#limitations-of-torch-fx-symbolic-trace-api">Limitations of torch.fx symbolic trace API</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_model_validator.html"> Model Validator API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html"> Quant Analyzer API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#aimet_torch.quant_analyzer.QuantAnalyzer"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#aimet_torch.quant_analyzer.QuantAnalyzer.analyze"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.analyze()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#aimet_torch.quant_analyzer.QuantAnalyzer.enable_per_layer_mse_loss"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.enable_per_layer_mse_loss()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quant_analyzer.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_quantsim.html"> Quantization Simulation API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quantsim.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quantsim.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quantsim.html#guidelines">Guidelines</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quantsim.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel.compute_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.compute_encodings()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel.export"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.export()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.save_checkpoint"><code class="docutils literal notranslate"><span class="pre">quantsim.save_checkpoint()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.load_checkpoint"><code class="docutils literal notranslate"><span class="pre">quantsim.load_checkpoint()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quantsim.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme"><code class="docutils literal notranslate"><span class="pre">QuantScheme</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.post_training_percentile"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_percentile</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.post_training_tf"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.post_training_tf_enhanced"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf_enhanced</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_enhanced_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_enhanced_init</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_quantsim.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_init</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_quantsim.html#code-example-quantization-aware-training-qat">Code Example - Quantization Aware Training (QAT)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_adaround.html"> Adaptive Rounding API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_adaround.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_adaround.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_adaround.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_torch.adaround.adaround_weight.Adaround.apply_adaround"><code class="docutils literal notranslate"><span class="pre">apply_adaround()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_adaround.html#adaround-parameters">Adaround Parameters</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_torch.adaround.adaround_weight.AdaroundParameters"><code class="docutils literal notranslate"><span class="pre">AdaroundParameters</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_adaround.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme"><code class="docutils literal notranslate"><span class="pre">QuantScheme</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.post_training_percentile"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_percentile</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.post_training_tf"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.post_training_tf_enhanced"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf_enhanced</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_enhanced_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_enhanced_init</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_init</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_adaround.html#code-example-adaptive-rounding-adaround">Code Example - Adaptive Rounding (AdaRound)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html"> Cross-Layer Equalization API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#introduction">Introduction</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#cross-layer-equalization-api">Cross Layer Equalization API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#aimet_torch.cross_layer_equalization.equalize_model"><code class="docutils literal notranslate"><span class="pre">equalize_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#code-example">Code Example</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_cross_layer_equalization.html#primitive-apis">Primitive APIs</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html">Primitive APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#introduction">Introduction</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#clssetinfo-definition">ClsSetInfo Definition</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.ClsSetInfo"><code class="docutils literal notranslate"><span class="pre">ClsSetInfo</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.ClsSetInfo.ClsSetLayerPairInfo"><code class="docutils literal notranslate"><span class="pre">ClsSetInfo.ClsSetLayerPairInfo</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#higher-level-apis-for-cross-layer-equalization">Higher Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.batch_norm_fold.fold_all_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.CrossLayerScaling.scale_model"><code class="docutils literal notranslate"><span class="pre">scale_model()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.HighBiasFold.bias_fold"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#code-examples-for-higher-level-apis">Code Examples for Higher Level APIs</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#lower-level-apis-for-cross-layer-equalization">Lower Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.batch_norm_fold.fold_given_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_given_batch_norms()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#aimet_torch.cross_layer_equalization.CrossLayerScaling.scale_cls_sets"><code class="docutils literal notranslate"><span class="pre">scale_cls_sets()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#id0"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_primitive_apis_cle.html#code-examples-for-lower-level-apis">Code Examples for Lower Level APIs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_bias_correction.html"> Bias Correction API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#bias-correction-api">Bias Correction API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_torch.bias_correction.correct_bias"><code class="docutils literal notranslate"><span class="pre">correct_bias()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#convbninfotype">ConvBnInfoType</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.bias_correction.ConvBnInfoType"><code class="docutils literal notranslate"><span class="pre">ConvBnInfoType</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#activationtype">ActivationType</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType"><code class="docutils literal notranslate"><span class="pre">ActivationType</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType.no_activation"><code class="docutils literal notranslate"><span class="pre">ActivationType.no_activation</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType.relu"><code class="docutils literal notranslate"><span class="pre">ActivationType.relu</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_common.defs.ActivationType.relu6"><code class="docutils literal notranslate"><span class="pre">ActivationType.relu6</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#quantization-params">Quantization Params</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#aimet_torch.quantsim.QuantParams"><code class="docutils literal notranslate"><span class="pre">QuantParams</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#code-example-1-empirical-bias-correction">Code Example #1 Empirical Bias Correction</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_bias_correction.html#code-example-2-analytical-empirical-bias-correction">Code Example #2 Analytical + Empirical Bias correction</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_auto_quant.html"> AutoQuant API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant"><code class="docutils literal notranslate"><span class="pre">AutoQuant</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.run_inference"><code class="docutils literal notranslate"><span class="pre">AutoQuant.run_inference()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.optimize"><code class="docutils literal notranslate"><span class="pre">AutoQuant.optimize()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.set_adaround_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_adaround_params()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.set_export_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_export_params()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.set_model_preparer_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_model_preparer_params()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.get_quant_scheme_candidates"><code class="docutils literal notranslate"><span class="pre">AutoQuant.get_quant_scheme_candidates()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant_v2.AutoQuant.set_quant_scheme_candidates"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_quant_scheme_candidates()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant.AutoQuant"><code class="docutils literal notranslate"><span class="pre">AutoQuant</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant.AutoQuant.apply"><code class="docutils literal notranslate"><span class="pre">AutoQuant.apply()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant.AutoQuant.set_adaround_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_adaround_params()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#aimet_torch.auto_quant.AutoQuant.set_export_params"><code class="docutils literal notranslate"><span class="pre">AutoQuant.set_export_params()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_auto_quant.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html"> BN Re-estimation APIs</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#introduction">Introduction</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#top-level-apis">Top-level APIs</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#aimet_torch.bn_reestimation.reestimate_bn_stats"><code class="docutils literal notranslate"><span class="pre">reestimate_bn_stats()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#aimet_torch.batch_norm_fold.fold_all_batch_norms_to_scale"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms_to_scale()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_batchnorm_re_estimation.html#code-example-bn-reestimation">Code Example - BN-Reestimation</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_multi_gpu.html"> Multi-GPU guidelines</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/torch_compress.html">PyTorch Model Compression API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#top-level-api-for-compression">Top-level API for Compression</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.compress.ModelCompressor"><code class="docutils literal notranslate"><span class="pre">ModelCompressor</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.compress.ModelCompressor.compress_model"><code class="docutils literal notranslate"><span class="pre">ModelCompressor.compress_model()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#greedy-selection-parameters">Greedy Selection Parameters</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_common.defs.GreedySelectionParameters"><code class="docutils literal notranslate"><span class="pre">GreedySelectionParameters</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#tar-selection-parameters">TAR Selection Parameters</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.TarRankSelectionParameters"><code class="docutils literal notranslate"><span class="pre">TarRankSelectionParameters</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#spatial-svd-configuration">Spatial SVD Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.Mode"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.SpatialSvdParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#weight-svd-configuration">Weight SVD Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.Mode"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.WeightSvdParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">WeightSvdParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#channel-pruning-configuration">Channel Pruning Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.Mode"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.ChannelPruningParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#configuration-definitions">Configuration Definitions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_compress.html#aimet_torch.defs.ModuleCompRatioPair"><code class="docutils literal notranslate"><span class="pre">ModuleCompRatioPair</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/torch_visualization_compression.html">PyTorch Model Visualization API for Compression</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_visualization_compression.html#top-level-api-compression">Top-level API Compression</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_visualization_compression.html#aimet_torch.visualize_serialized_data.VisualizeCompression"><code class="docutils literal notranslate"><span class="pre">VisualizeCompression</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_visualization_compression.html#aimet_torch.visualize_serialized_data.VisualizeCompression.display_eval_scores"><code class="docutils literal notranslate"><span class="pre">VisualizeCompression.display_eval_scores()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_visualization_compression.html#aimet_torch.visualize_serialized_data.VisualizeCompression.display_comp_ratio_plot"><code class="docutils literal notranslate"><span class="pre">VisualizeCompression.display_comp_ratio_plot()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_visualization_compression.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/torch_visualization_quantization.html">PyTorch Model Visualization API for Quantization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_visualization_quantization.html#top-level-api-quantization">Top-level API Quantization</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_visualization_quantization.html#aimet_torch.visualize_model.visualize_relative_weight_ranges_to_identify_problematic_layers"><code class="docutils literal notranslate"><span class="pre">visualize_relative_weight_ranges_to_identify_problematic_layers()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_visualization_quantization.html#aimet_torch.visualize_model.visualize_weight_ranges"><code class="docutils literal notranslate"><span class="pre">visualize_weight_ranges()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_visualization_quantization.html#aimet_torch.visualize_model.visualize_changes_after_optimization"><code class="docutils literal notranslate"><span class="pre">visualize_changes_after_optimization()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_visualization_quantization.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html">PyTorch Debug API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.LayerOutputUtil"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.LayerOutputUtil.generate_layer_outputs"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil.generate_layer_outputs()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.NamingScheme"><code class="docutils literal notranslate"><span class="pre">NamingScheme</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.NamingScheme.ONNX"><code class="docutils literal notranslate"><span class="pre">NamingScheme.ONNX</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.NamingScheme.PYTORCH"><code class="docutils literal notranslate"><span class="pre">NamingScheme.PYTORCH</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html#aimet_torch.layer_output_utils.NamingScheme.TORCHSCRIPT"><code class="docutils literal notranslate"><span class="pre">NamingScheme.TORCHSCRIPT</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_layer_output_generation.html#code-example">Code Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api_docs/tensorflow.html">AIMET APIs for TensorFlow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/tensorflow_model_guidelines.html">TensorFlow Model Guidelines</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_model_guidelines.html#aimet_tensorflow.utils.graph.update_keras_bn_ops_trainable_flag"><code class="docutils literal notranslate"><span class="pre">update_keras_bn_ops_trainable_flag()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/tensorflow_quantization.html">TensorFlow Model Quantization API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/tensorflow_compress.html">TensorFlow Model Compression API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#top-level-api-for-compression">Top-level API for Compression</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.compress.ModelCompressor"><code class="docutils literal notranslate"><span class="pre">ModelCompressor</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.compress.ModelCompressor.compress_model"><code class="docutils literal notranslate"><span class="pre">ModelCompressor.compress_model()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#greedy-selection-parameters">Greedy Selection Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#spatial-svd-configuration">Spatial SVD Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.SpatialSvdParameters"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.SpatialSvdParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.SpatialSvdParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.SpatialSvdParameters.Mode"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.SpatialSvdParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.SpatialSvdParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#channel-pruning-configuration">Channel Pruning Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.ChannelPruningParameters"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.ChannelPruningParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.ChannelPruningParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.ChannelPruningParameters.Mode"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.ChannelPruningParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.ChannelPruningParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">ChannelPruningParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#configuration-definitions">Configuration Definitions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_common.defs.CostMetric"><code class="docutils literal notranslate"><span class="pre">CostMetric</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_common.defs.CostMetric.mac"><code class="docutils literal notranslate"><span class="pre">CostMetric.mac</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_common.defs.CostMetric.memory"><code class="docutils literal notranslate"><span class="pre">CostMetric.memory</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_common.defs.CompressionScheme"><code class="docutils literal notranslate"><span class="pre">CompressionScheme</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_common.defs.CompressionScheme.channel_pruning"><code class="docutils literal notranslate"><span class="pre">CompressionScheme.channel_pruning</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_common.defs.CompressionScheme.spatial_svd"><code class="docutils literal notranslate"><span class="pre">CompressionScheme.spatial_svd</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_common.defs.CompressionScheme.weight_svd"><code class="docutils literal notranslate"><span class="pre">CompressionScheme.weight_svd</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.defs.ModuleCompRatioPair"><code class="docutils literal notranslate"><span class="pre">ModuleCompRatioPair</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#code-examples">Code Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#weight-svd-top-level-api">Weight SVD Top-level API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.svd.Svd"><code class="docutils literal notranslate"><span class="pre">Svd</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#aimet_tensorflow.svd.Svd.compress_net"><code class="docutils literal notranslate"><span class="pre">Svd.compress_net()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#code-examples-for-weight-svd">Code Examples for Weight SVD</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/tensorflow_visualization_quantization.html">TensorFlow Model Visualization API for Quantization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_visualization_quantization.html#top-level-api-for-visualization-of-weight-tensors">Top-level API for Visualization of Weight tensors</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_visualization_quantization.html#aimet_tensorflow.plotting_utils.visualize_weight_ranges_single_layer"><code class="docutils literal notranslate"><span class="pre">visualize_weight_ranges_single_layer()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_visualization_quantization.html#aimet_tensorflow.plotting_utils.visualize_relative_weight_ranges_single_layer"><code class="docutils literal notranslate"><span class="pre">visualize_relative_weight_ranges_single_layer()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_visualization_quantization.html#code-examples-for-visualization-of-weight-tensors">Code Examples for Visualization of Weight tensors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html">Using AIMET Tensorflow APIs with Keras Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#apis">APIs</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#aimet_tensorflow.utils.convert_tf_sess_to_keras.save_tf_session_single_gpu"><code class="docutils literal notranslate"><span class="pre">save_tf_session_single_gpu()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#aimet_tensorflow.utils.convert_tf_sess_to_keras.load_tf_sess_variables_to_keras_single_gpu"><code class="docutils literal notranslate"><span class="pre">load_tf_sess_variables_to_keras_single_gpu()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#aimet_tensorflow.utils.convert_tf_sess_to_keras.save_as_tf_module_multi_gpu"><code class="docutils literal notranslate"><span class="pre">save_as_tf_module_multi_gpu()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#aimet_tensorflow.utils.convert_tf_sess_to_keras.load_keras_model_multi_gpu"><code class="docutils literal notranslate"><span class="pre">load_keras_model_multi_gpu()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#code-example">Code Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#utility-functions">Utility Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/tensorflow_layer_output_generation.html">Tensorflow Debug API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_layer_output_generation.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/tensorflow_layer_output_generation.html#aimet_tensorflow.layer_output_utils.LayerOutputUtil"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/tensorflow_layer_output_generation.html#aimet_tensorflow.layer_output_utils.LayerOutputUtil.generate_layer_outputs"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil.generate_layer_outputs()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_layer_output_generation.html#code-example">Code Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api_docs/keras.html">AIMET APIs for Keras</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/keras_quantization.html">Keras Model Quantization API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_model_guidelines.html"> Model Guidelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_model_preparer.html"> Model Preparer API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_model_preparer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_model_preparer.html#aimet_tensorflow.keras.model_preparer.prepare_model"><code class="docutils literal notranslate"><span class="pre">prepare_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_model_preparer.html#code-examples">Code Examples</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_model_preparer.html#limitations">Limitations</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_quant_analyzer.html"> Quant Analyzer API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_quant_analyzer.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_quant_analyzer.html#aimet_tensorflow.keras.quant_analyzer.QuantAnalyzer"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_quant_analyzer.html#aimet_tensorflow.keras.quant_analyzer.QuantAnalyzer.analyze"><code class="docutils literal notranslate"><span class="pre">QuantAnalyzer.analyze()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_quant_analyzer.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_quantsim.html"> Quantization Simulation API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_quantsim.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_quantsim.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_quantsim.html#aimet_tensorflow.keras.quantsim.QuantizationSimModel"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_quantsim.html#aimet_tensorflow.keras.quantsim.QuantizationSimModel.compute_encodings"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.compute_encodings()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_quantsim.html#aimet_tensorflow.keras.quantsim.QuantizationSimModel.export"><code class="docutils literal notranslate"><span class="pre">QuantizationSimModel.export()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_quantsim.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_adaround.html"> Adaptive Rounding API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_adaround.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_adaround.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_adaround.html#top-level-api">Top-level API</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_adaround.html#adaround-parameters">Adaround Parameters</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_adaround.html#aimet_tensorflow.adaround.adaround_weight.AdaroundParameters"><code class="docutils literal notranslate"><span class="pre">AdaroundParameters</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_adaround.html#enum-definition">Enum Definition</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme"><code class="docutils literal notranslate"><span class="pre">QuantScheme</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.post_training_percentile"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_percentile</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.post_training_tf"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.post_training_tf_enhanced"><code class="docutils literal notranslate"><span class="pre">QuantScheme.post_training_tf_enhanced</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_enhanced_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_enhanced_init</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_adaround.html#aimet_common.defs.QuantScheme.training_range_learning_with_tf_init"><code class="docutils literal notranslate"><span class="pre">QuantScheme.training_range_learning_with_tf_init</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_adaround.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_cross_layer_equalization.html"> Cross-Layer Equalization API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_cross_layer_equalization.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_cross_layer_equalization.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_cross_layer_equalization.html#introduction">Introduction</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_cross_layer_equalization.html#cross-layer-equalization-api">Cross Layer Equalization API</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_cross_layer_equalization.html#aimet_tensorflow.keras.cross_layer_equalization.equalize_model"><code class="docutils literal notranslate"><span class="pre">equalize_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_cross_layer_equalization.html#code-example">Code Example</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_cross_layer_equalization.html#primitive-apis">Primitive APIs</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html">Primitive APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#introduction">Introduction</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#higher-level-apis-for-cross-layer-equalization">Higher Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.batch_norm_fold.fold_all_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.CrossLayerScaling.scale_model"><code class="docutils literal notranslate"><span class="pre">scale_model()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.HighBiasFold.bias_fold"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#code-examples-for-higher-level-apis">Code Examples for Higher Level APIs</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#lower-level-apis-for-cross-layer-equalization">Lower Level APIs for Cross Layer Equalization</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.batch_norm_fold.fold_given_batch_norms"><code class="docutils literal notranslate"><span class="pre">fold_given_batch_norms()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.CrossLayerScaling.scale_cls_sets"><code class="docutils literal notranslate"><span class="pre">scale_cls_sets()</span></code></a></li>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#id0"><code class="docutils literal notranslate"><span class="pre">bias_fold()</span></code></a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#custom-datatype-used">Custom Datatype used</a><ul>
<li class="toctree-l8"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.ClsSetInfo"><code class="docutils literal notranslate"><span class="pre">ClsSetInfo</span></code></a><ul>
<li class="toctree-l9"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#aimet_tensorflow.keras.cross_layer_equalization.ClsSetInfo.ClsSetLayerPairInfo"><code class="docutils literal notranslate"><span class="pre">ClsSetInfo.ClsSetLayerPairInfo</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#code-example-for-lower-level-apis">Code Example for Lower level APIs</a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_primitive_apis_cle.html#example-helper-methods-to-perform-cle-in-manual-mode">Example helper methods to perform CLE in manual mode</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_batchnorm_re_estimation.html"> BN Re-estimation APIs</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_batchnorm_re_estimation.html#examples-notebook-link">Examples Notebook Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_batchnorm_re_estimation.html#introduction">Introduction</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_batchnorm_re_estimation.html#top-level-apis">Top-level APIs</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_batchnorm_re_estimation.html#aimet_tensorflow.keras.bn_reestimation.reestimate_bn_stats"><code class="docutils literal notranslate"><span class="pre">reestimate_bn_stats()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_batchnorm_re_estimation.html#aimet_tensorflow.keras.batch_norm_fold.fold_all_batch_norms_to_scale"><code class="docutils literal notranslate"><span class="pre">fold_all_batch_norms_to_scale()</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_batchnorm_re_estimation.html#code-example">Code Example</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_batchnorm_re_estimation.html#limitations">Limitations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/keras_layer_output_generation.html">Keras Debug API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_layer_output_generation.html#top-level-api">Top-level API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_layer_output_generation.html#aimet_tensorflow.keras.layer_output_utils.LayerOutputUtil"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_layer_output_generation.html#aimet_tensorflow.keras.layer_output_utils.LayerOutputUtil.generate_layer_outputs"><code class="docutils literal notranslate"><span class="pre">LayerOutputUtil.generate_layer_outputs()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_layer_output_generation.html#code-example">Code Example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/keras_compression.html">Keras Model Compression API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_compression.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_compression.html#top-level-api-for-compression">Top-level API for Compression</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_tensorflow.keras.compress.ModelCompressor"><code class="docutils literal notranslate"><span class="pre">ModelCompressor</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_tensorflow.keras.compress.ModelCompressor.compress_model"><code class="docutils literal notranslate"><span class="pre">ModelCompressor.compress_model()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_compression.html#greedy-selection-parameters">Greedy Selection Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_compression.html#spatial-svd-configuration">Spatial SVD Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_tensorflow.defs.SpatialSvdParameters"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_tensorflow.defs.SpatialSvdParameters.AutoModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.AutoModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_tensorflow.defs.SpatialSvdParameters.ManualModeParams"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.ManualModeParams</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_tensorflow.defs.SpatialSvdParameters.Mode"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode</span></code></a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_tensorflow.defs.SpatialSvdParameters.Mode.auto"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.auto</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_tensorflow.defs.SpatialSvdParameters.Mode.manual"><code class="docutils literal notranslate"><span class="pre">SpatialSvdParameters.Mode.manual</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_compression.html#configuration-definitions">Configuration Definitions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_common.defs.CostMetric"><code class="docutils literal notranslate"><span class="pre">CostMetric</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_common.defs.CostMetric.mac"><code class="docutils literal notranslate"><span class="pre">CostMetric.mac</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_common.defs.CostMetric.memory"><code class="docutils literal notranslate"><span class="pre">CostMetric.memory</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_common.defs.CompressionScheme"><code class="docutils literal notranslate"><span class="pre">CompressionScheme</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_common.defs.CompressionScheme.channel_pruning"><code class="docutils literal notranslate"><span class="pre">CompressionScheme.channel_pruning</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_common.defs.CompressionScheme.spatial_svd"><code class="docutils literal notranslate"><span class="pre">CompressionScheme.spatial_svd</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_common.defs.CompressionScheme.weight_svd"><code class="docutils literal notranslate"><span class="pre">CompressionScheme.weight_svd</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/keras_compression.html#aimet_tensorflow.defs.ModuleCompRatioPair"><code class="docutils literal notranslate"><span class="pre">ModuleCompRatioPair</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/keras_compression.html#code-examples">Code Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api_docs/onnx.html">AIMET APIs for ONNX</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/onnx_quantization.html">ONNX Model Quantization API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/onnx_quantsim.html"> Quantization Simulation API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_quantsim.html#top-level-api">Top-level API</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_quantsim.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/onnx_cross_layer_equalization.html"> Cross-Layer Equalization API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_cross_layer_equalization.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_cross_layer_equalization.html#introduction">Introduction</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_cross_layer_equalization.html#cross-layer-equalization-api">Cross Layer Equalization API</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_cross_layer_equalization.html#code-example">Code Example</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/onnx_adaround.html"> Adaptive Rounding API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_adaround.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_adaround.html#top-level-api">Top-level API</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_adaround.html#adaround-parameters">Adaround Parameters</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_adaround.html#code-example-adaptive-rounding-adaround">Code Example - Adaptive Rounding (AdaRound)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/onnx_auto_quant.html"> AutoQuant API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_auto_quant.html#user-guide-link">User Guide Link</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_auto_quant.html#top-level-api">Top-level API</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_auto_quant.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/onnx_quant_analyzer.html"> QuantAnalyzer API</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_quant_analyzer.html#top-level-api">Top-level API</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_quant_analyzer.html#run-specific-utility">Run specific utility</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../api_docs/onnx_quant_analyzer.html#code-examples">Code Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/onnx_layer_output_generation.html">ONNX Debug API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/onnx_layer_output_generation.html#top-level-api">Top-level API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/onnx_layer_output_generation.html#code-example">Code Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api_docs/index.html#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/examples.html"> Examples Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/examples.html#browse-the-notebooks">Browse the notebooks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/examples.html#running-the-notebooks">Running the notebooks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/examples.html#install-jupyter">Install Jupyter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/examples.html#download-the-example-notebooks-and-related-code">Download the Example notebooks and related code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/examples.html#run-the-notebooks">Run the notebooks</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html"> Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../install/index.html#quick-install">Quick Install</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../install/index.html#release-packages">Release Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../install/index.html#system-requirements">System Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../install/index.html#advanced-installation-instructions">Advanced Installation Instructions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../install/install_host.html">Install in Host Machine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#install-prerequisite-packages">Install prerequisite packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#install-gpu-packages">Install GPU packages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../install/install_host.html#install-gpu-packages-for-pytorch-1-13-or-onnx">Install GPU packages for PyTorch 1.13 or ONNX</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../install/install_host.html#install-gpu-packages-for-pytorch-2-1-or-tensorflow">Install GPU packages for PyTorch 2.1 or TensorFlow</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#install-aimet-packages">Install AIMET packages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../install/install_host.html#from-pypi">From PyPI</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../install/install_host.html#from-release-package">From Release Package</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#install-common-debian-packages">Install common debian packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#install-tensorflow-gpu-debian-packages">Install tensorflow GPU debian packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#install-torch-gpu-debian-packages">Install torch GPU debian packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#install-onnx-gpu-debian-packages">Install ONNX GPU debian packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#replace-pillow-with-pillow-simd">Replace Pillow with Pillow-SIMD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#replace-onnxruntime-with-onnxruntime-gpu">Replace onnxruntime with onnxruntime-gpu</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#post-installation-steps">Post installation steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_host.html#environment-setup">Environment setup</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../install/install_docker.html">Install in Docker Container</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_docker.html#set-variant">Set variant</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_docker.html#use-prebuilt-docker-image">Use prebuilt docker image</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_docker.html#build-docker-image-locally">Build docker image locally</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_docker.html#start-docker-container">Start docker container</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_docker.html#install-aimet-packages">Install AIMET packages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../install/install_docker.html#from-pypi">From PyPI</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../install/install_docker.html#from-release-package">From Release Package</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../install/install_docker.html#environment-setup">Environment setup</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../user_guide/index.html">AI Model Efficiency Toolkit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../user_guide/index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">aimet_torch.quantsim</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aimet_torch.quantsim</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- mode: python -*-</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#  @@-COPYRIGHT-START-@@</span>
<span class="c1">#</span>
<span class="c1">#  Copyright (c) 2019-2024, Qualcomm Innovation Center, Inc. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1">#  Redistribution and use in source and binary forms, with or without</span>
<span class="c1">#  modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1">#  1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#     this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#  2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#     this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#     and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1">#  3. Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1">#     may be used to endorse or promote products derived from this software</span>
<span class="c1">#     without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1">#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1">#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1">#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1">#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1">#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1">#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1">#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1">#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1">#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1">#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1">#  POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1">#  SPDX-License-Identifier: BSD-3-Clause</span>
<span class="c1">#</span>
<span class="c1">#  @@-COPYRIGHT-END-@@</span>
<span class="c1"># =============================================================================</span>

<span class="sd">&quot;&quot;&quot; Implementation for simulating models running on Quantized hardware &quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=too-many-lines</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">runtime_checkable</span><span class="p">,</span> <span class="n">Protocol</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">onnx</span>
<span class="kn">from</span> <span class="nn">packaging</span> <span class="kn">import</span> <span class="n">version</span>  <span class="c1"># pylint: disable=wrong-import-order</span>

<span class="kn">import</span> <span class="nn">aimet_common</span>
<span class="kn">import</span> <span class="nn">aimet_common.libpymo</span> <span class="k">as</span> <span class="nn">libpymo</span>

<span class="kn">from</span> <span class="nn">aimet_common.connected_graph.connectedgraph_utils</span> <span class="kn">import</span> <span class="n">CG_SPLIT</span>
<span class="kn">from</span> <span class="nn">aimet_common.utils</span> <span class="kn">import</span> <span class="n">AimetLogger</span><span class="p">,</span> <span class="n">save_json_yaml</span><span class="p">,</span> <span class="n">log_with_error_and_assert_if_false</span>
<span class="kn">from</span> <span class="nn">aimet_common.defs</span> <span class="kn">import</span> <span class="n">QuantScheme</span><span class="p">,</span> <span class="n">QuantizationDataType</span><span class="p">,</span> <span class="n">SupportedKernelsAction</span><span class="p">,</span> <span class="n">QuantDtypeBwInfo</span>
<span class="kn">from</span> <span class="nn">aimet_common.quantsim</span> <span class="kn">import</span> <span class="n">encoding_version</span><span class="p">,</span> <span class="n">validate_quantsim_inputs</span><span class="p">,</span> <span class="n">extract_global_quantizer_args</span>
<span class="kn">from</span> <span class="nn">aimet_common.quant_utils</span> <span class="kn">import</span> <span class="n">get_conv_accum_bounds</span>

<span class="kn">from</span> <span class="nn">aimet_torch.quantsim_config.quantsim_config</span> <span class="kn">import</span> <span class="n">QuantSimConfigurator</span>
<span class="kn">from</span> <span class="nn">aimet_torch.qc_quantize_op</span> <span class="kn">import</span> <span class="n">QcQuantizeStandAloneBase</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeOpMode</span><span class="p">,</span> \
    <span class="n">StaticGridQuantWrapper</span><span class="p">,</span> <span class="n">LearnedGridQuantWrapper</span><span class="p">,</span> <span class="n">NativeTorchQuantWrapper</span><span class="p">,</span> <span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">,</span> <span class="n">QUANTIZER_TYPE_OUTPUT</span>
<span class="kn">from</span> <span class="nn">aimet_torch.tensor_quantizer</span> <span class="kn">import</span> <span class="n">initialize_learned_grid_quantizer_attributes</span>
<span class="kn">from</span> <span class="nn">aimet_torch.qc_quantize_op</span> <span class="kn">import</span> <span class="n">get_encoding_by_quantizer</span> <span class="k">as</span> <span class="n">_get_encoding_by_quantizer</span>
<span class="kn">from</span> <span class="nn">aimet_torch</span> <span class="kn">import</span> <span class="n">torchscript_utils</span><span class="p">,</span> <span class="n">utils</span><span class="p">,</span> <span class="n">transformer_utils</span><span class="p">,</span> <span class="n">onnx_utils</span>
<span class="kn">from</span> <span class="nn">aimet_torch.onnx_utils</span> <span class="kn">import</span> <span class="n">OnnxSaver</span><span class="p">,</span> <span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="n">CustomMarker</span><span class="p">,</span> <span class="n">get_pytorch_name_from_onnx_name</span>
<span class="kn">from</span> <span class="nn">aimet_torch.meta.connectedgraph</span> <span class="kn">import</span> <span class="n">ConnectedGraph</span>
<span class="kn">from</span> <span class="nn">aimet_torch.qc_quantize_recurrent</span> <span class="kn">import</span> <span class="n">QcQuantizeRecurrent</span>
<span class="kn">from</span> <span class="nn">aimet_torch.v2.quantization.builder</span> <span class="kn">import</span> <span class="n">LazyQuantizeWrapper</span>
<span class="kn">from</span> <span class="nn">aimet_torch.v2.nn</span> <span class="kn">import</span> <span class="n">BaseQuantizationMixin</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">AimetLogger</span><span class="o">.</span><span class="n">get_area_logger</span><span class="p">(</span><span class="n">AimetLogger</span><span class="o">.</span><span class="n">LogAreas</span><span class="o">.</span><span class="n">Quant</span><span class="p">)</span>

<span class="c1"># Types of modules which cannot be quantized</span>
<span class="n">unquantizable_modules</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">QcQuantizeWrapper</span><span class="p">,</span>
    <span class="n">QcQuantizeStandAloneBase</span><span class="p">,</span>
    <span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
    <span class="n">BaseQuantizationMixin</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># If a torch module type is in this dictionary, call the corresponding quantized module constructor instead of wrapping</span>
<span class="c1"># it with QcQuantizeWrapper.</span>
<span class="n">qc_quantize_modules_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">RNN</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">LSTM</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">GRU</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span>
<span class="p">}</span>

<span class="c1"># Length of the string &#39;._module_to_wrap&#39;</span>
<span class="n">MODULE_TO_WRAP_STRING_REVERSE_INDEX</span> <span class="o">=</span> <span class="o">-</span><span class="mi">16</span>

<span class="n">MAP_PYMO_TO_ROUND_MODE</span> <span class="o">=</span> <span class="p">{</span><span class="n">libpymo</span><span class="o">.</span><span class="n">RoundingMode</span><span class="o">.</span><span class="n">ROUND_NEAREST</span><span class="p">:</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                          <span class="n">libpymo</span><span class="o">.</span><span class="n">RoundingMode</span><span class="o">.</span><span class="n">ROUND_STOCHASTIC</span><span class="p">:</span> <span class="s1">&#39;stochastic&#39;</span><span class="p">}</span>

<span class="n">SUPPORTED_KERNELS_ACTION</span> <span class="o">=</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">warn_on_error</span>


<div class="viewcode-block" id="QuantParams"><a class="viewcode-back" href="../../api_docs/torch_bias_correction.html#aimet_torch.quantsim.QuantParams">[docs]</a><span class="k">class</span> <span class="nc">QuantParams</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data type to hold quantization related params.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">weight_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">act_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">round_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                 <span class="n">quant_scheme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">QuantScheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                 <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>

<span class="sd">        :param weight_bw: Weight bitwidth (4-31) to use for quantizing layer weights. Default = 8</span>
<span class="sd">        :param act_bw: Activation bitwidth(4-31) to use for quantizing layer activations. Default = 8</span>
<span class="sd">        :param round_mode: Rounding mode. Supported options are &#39;nearest&#39; or &#39;stochastic&#39;</span>
<span class="sd">        :param quant_scheme: Quantization scheme. Supported options are &#39;tf_enhanced&#39; or &#39;tf&#39; or using Quant Scheme Enum</span>
<span class="sd">                             QuantScheme.post_training_tf or QuantScheme.post_training_tf_enhanced</span>
<span class="sd">        :param config_file: Path to Configuration file for model quantizers</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weight_bw</span> <span class="o">=</span> <span class="n">weight_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">act_bw</span> <span class="o">=</span> <span class="n">act_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">round_mode</span> <span class="o">=</span> <span class="n">round_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">quant_scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_file</span> <span class="o">=</span> <span class="n">config_file</span></div>


<span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">ExportableQuantModule</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines the minimum interface requirements for exporting encodings from a module.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">export_input_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of input encodings, each represented as a List of Dicts</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">export_output_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of output encodings, each represented as a List of Dicts</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">export_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dict of {param name: param encodings}, with each encoding represented as a List of Dicts</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">import_input_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">],</span> <span class="n">ignore_when_quantizer_disabled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">disable_quantizer_without_encoding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">freeze</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import input encodings represented in below format:</span>
<span class="sd">        {</span>
<span class="sd">            &#39;0&#39;: dict,</span>
<span class="sd">            &#39;1&#39;: dict,</span>
<span class="sd">            ...</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">import_output_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">],</span> <span class="n">ignore_when_quantizer_disabled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">disable_quantizer_without_encoding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">freeze</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import output encodings represented in below format:</span>
<span class="sd">        {</span>
<span class="sd">            &#39;0&#39;: dict,</span>
<span class="sd">            &#39;1&#39;: dict,</span>
<span class="sd">            ...</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">import_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]],</span> <span class="n">ignore_when_quantizer_disabled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">disable_quantizer_without_encoding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">freeze</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import parameter encodings represented in below format:</span>
<span class="sd">        {</span>
<span class="sd">            &#39;param_name_0&#39;: [dict, dict, ...],</span>
<span class="sd">            &#39;param_name_1&#39;: [dict, dict, ...],</span>
<span class="sd">            ...</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_original_module</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the floating point version of quantized module</span>
<span class="sd">        &quot;&quot;&quot;</span>


<div class="viewcode-block" id="QuantizationSimModel"><a class="viewcode-back" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel">[docs]</a><span class="k">class</span> <span class="nc">QuantizationSimModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements mechanism to add quantization simulations ops to a model. This allows for off-target simulation of</span>
<span class="sd">    inference accuracy. Also allows the model to be fine-tuned to counter the effects of quantization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-arguments, too-many-instance-attributes, too-many-locals, too-many-public-methods</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                 <span class="n">quant_scheme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                 <span class="n">rounding_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">default_data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span> <span class="o">=</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for QuantizationSimModel.</span>

<span class="sd">        :param model: Model to add simulation ops to</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph. If the model has more than one input,</span>
<span class="sd">                            pass a tuple. User is expected to place the tensors on the appropriate device.</span>
<span class="sd">        :param quant_scheme: Quantization scheme. The Quantization scheme is used to compute the Quantization encodings.</span>
<span class="sd">                             There are multiple schemes available. Please refer the QuantScheme enum definition.</span>
<span class="sd">        :param rounding_mode: Rounding mode. Supported options are &#39;nearest&#39; or &#39;stochastic&#39;</span>
<span class="sd">        :param default_output_bw: Default bitwidth (4-31) to use for quantizing all layer inputs and outputs</span>
<span class="sd">        :param default_param_bw: Default bitwidth (4-31) to use for quantizing all layer parameters</span>
<span class="sd">        :param in_place: If True, then the given &#39;model&#39; is modified in-place to add quant-sim nodes.</span>
<span class="sd">                Only suggested use of this option is when the user wants to avoid creating a copy of the model</span>
<span class="sd">        :param config_file: Path to Configuration file for model quantizers</span>
<span class="sd">        :param default_data_type: Default data type to use for quantizing all layer inputs, outputs and parameters.</span>
<span class="sd">                                 Possible options are QuantizationDataType.int and QuantizationDataType.float.</span>
<span class="sd">                                 Note that the mode default_data_type=QuantizationDataType.float is only supported with</span>
<span class="sd">                                 default_output_bw=16 and default_param_bw=16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform sanity checks on inputs</span>
        <span class="n">validate_quantsim_inputs</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span> <span class="n">rounding_mode</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">,</span>
                                 <span class="n">default_data_type</span><span class="p">)</span>
        <span class="c1"># save some parameters</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="o">=</span> <span class="n">ConnectedGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">TracingCheckError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">quant_scheme</span> <span class="o">==</span> <span class="s1">&#39;tf&#39;</span><span class="p">:</span>
                <span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span>
            <span class="k">elif</span> <span class="n">quant_scheme</span> <span class="o">==</span> <span class="s1">&#39;tf_enhanced&#39;</span><span class="p">:</span>
                <span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span>
            <span class="k">elif</span> <span class="n">quant_scheme</span> <span class="o">==</span> <span class="s1">&#39;percentile&#39;</span><span class="p">:</span>
                <span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">=</span> <span class="n">quant_scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rounding_mode</span> <span class="o">=</span> <span class="n">rounding_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span> <span class="o">=</span> <span class="n">default_output_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_param_bw</span> <span class="o">=</span> <span class="n">default_param_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config_file</span> <span class="o">=</span> <span class="n">config_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_percentile_value</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># default percentile value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Add quantization layers</span>
        <span class="n">num_inout_tensors</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_num_inout_tensors_per_module</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>
        <span class="n">inout_tensors_dtypes_for_cast_ops</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_inout_tensors_dtypes_for_cast_modules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_quantization_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_tensor_quantizers_for_consts</span><span class="p">()</span>

        <span class="c1"># Disable bias quantization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_param_from_quantization</span><span class="p">(</span><span class="s2">&quot;bias&quot;</span><span class="p">)</span>

        <span class="c1"># override specific quantizers to tf mode in transformer model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_override_quant_config_for_transformer_layers</span><span class="p">()</span>

        <span class="n">quantsim_configurator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">configure_quantization_ops</span><span class="p">(</span><span class="n">config_file</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">,</span>
                                                                <span class="n">default_data_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">quant_args</span> <span class="o">=</span> <span class="n">extract_global_quantizer_args</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span> <span class="n">quantsim_configurator</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_output_quantizers_for_specific_cast_ops</span><span class="p">(</span><span class="n">inout_tensors_dtypes_for_cast_ops</span><span class="p">)</span>

        <span class="c1"># pylint: disable=protected-access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hw_version</span> <span class="o">=</span> <span class="n">quantsim_configurator</span><span class="o">.</span><span class="n">_get_hw_version</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_supported_kernels</span> <span class="o">=</span> <span class="n">quantsim_configurator</span><span class="o">.</span><span class="n">get_supported_kernels</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_supported_kernels_for_quantizers</span><span class="p">(</span><span class="n">SUPPORTED_KERNELS_ACTION</span><span class="p">)</span>

        <span class="c1"># Initialize real wrappers using collected information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_realize_quant_wrappers_in_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_realize_quant_wrappers_in_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare QuantSim for compute encodings. Resets encodings for each quantizable layer and sets mode to Analysis.</span>
<span class="sd">        Realize quant wrappers using collected information in LazyQuantWrapper.</span>

<span class="sd">        :param model: model containing modules wrapped with LazyQuantWrapper</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">):</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_realize_quant_wrapper</span><span class="p">(</span><span class="n">module_ref</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_realize_quant_wrappers_in_model</span><span class="p">(</span><span class="n">module_ref</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_realize_quant_wrapper</span><span class="p">(</span><span class="n">module</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QcQuantizeWrapper</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">module</span><span class="o">.</span><span class="n">realize_v1_wrapper</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_supported_kernels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return _supported_kernels parsed from the config file</span>
<span class="sd">        :return: Dictionary containing supported_kernels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_supported_kernels</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty-printed output indicating where in the model, quantizers have been activated</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">prefix_string</span><span class="si">}</span><span class="s1">: bw=</span><span class="si">{</span><span class="n">quantizer</span><span class="o">.</span><span class="n">bitwidth</span><span class="si">}</span><span class="s1">, &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;encoding-present=</span><span class="si">{</span><span class="nb">bool</span><span class="p">(</span><span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    </span><span class="si">{</span><span class="n">quantizer</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">prefix_string</span><span class="si">}</span><span class="s1">: Not quantized</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;  -------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">newline</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;-------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Quantized Model Report</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;-------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_qc_quantized_layers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">):</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Layer: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">layer_name</span><span class="p">))</span>

            <span class="c1"># Inputs</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Input[</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">):</span>
                    <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Input[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

            <span class="c1"># Params</span>
            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Param[</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

            <span class="c1"># Outputs</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Output[</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">):</span>
                    <span class="n">print_quantizer_state</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Output[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">prepare_sim_for_compute_encodings</span><span class="p">(</span><span class="n">sim</span><span class="p">:</span> <span class="s1">&#39;QuantizationSimModel&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare QuantSim for compute encodings. Resets encodings for each quantizable layer and sets mode to Analysis.</span>

<span class="sd">        :param sim: QuantSim to prepare</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">quantized_layers</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">_get_qc_quantized_layers</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quantized_layers</span><span class="p">:</span>
            <span class="c1"># Clear stats and encodings if they are present</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">reset_encodings</span><span class="p">()</span>

            <span class="c1"># And set the mode to analysis</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ANALYSIS</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quantized_layers</span><span class="p">:</span>
            <span class="c1"># call only when quant scheme is percentile</span>
            <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span><span class="p">:</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">set_percentile_value</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">_percentile_value</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_layer_encodings_for_sim</span><span class="p">(</span><span class="n">sim</span><span class="p">:</span> <span class="s1">&#39;QuantizationSimModel&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute encodings for each quantizable layer in sim after forward pass has been called.</span>

<span class="sd">        :param sim: QuantSim to compute encodings for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">quantized_layers</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">_get_qc_quantized_layers</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="c1"># Get the computed per-layer encodings and log them</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quantized_layers</span><span class="p">:</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">compute_encoding</span><span class="p">()</span>

            <span class="c1"># Before we return we set the mode to active - meaning ready for quantize/de-quantize</span>
            <span class="c1"># for layers with valid_encoding, otherwise we set to pass through</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                <span class="n">sim</span><span class="o">.</span><span class="n">set_mode_for_recurrent_module</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># By default we want to set the Quantization wrappers to ACTIVE mode</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">)</span>

        <span class="n">sim</span><span class="o">.</span><span class="n">replace_wrappers_for_quantize_dequantize</span><span class="p">()</span>

        <span class="n">sim</span><span class="o">.</span><span class="n">_clamp_transformer_attention_mask_encoding</span><span class="p">()</span>

<div class="viewcode-block" id="QuantizationSimModel.compute_encodings"><a class="viewcode-back" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel.compute_encodings">[docs]</a>    <span class="k">def</span> <span class="nf">compute_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_pass_callback</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes encodings for all quantization sim nodes in the model. It is also used to find initial encodings for</span>
<span class="sd">        Range Learning</span>

<span class="sd">        :param forward_pass_callback: A callback function that simply runs forward passes on the model. This callback</span>
<span class="sd">            function should use representative data for the forward pass, so the calculated encodings work for all</span>
<span class="sd">            data samples. This callback internally chooses the number of data samples it wants to use for calculating</span>
<span class="sd">            encodings.</span>
<span class="sd">        :param forward_pass_callback_args: These argument(s) are passed to the forward_pass_callback as-is. Up to</span>
<span class="sd">            the user to determine the type of this parameter. E.g. could be simply an integer representing the number</span>
<span class="sd">            of data samples to use. Or could be a tuple of parameters or an object representing something more complex.</span>
<span class="sd">            If set to None, forward_pass_callback will be invoked with no parameters.</span>
<span class="sd">        :return: None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">prepare_sim_for_compute_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Run forward iterations so we can collect statistics to compute the appropriate encodings</span>
        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">forward_pass_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">)</span>

        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">compute_layer_encodings_for_sim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set_mode_for_recurrent_module</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets Recurrent module to active or pass through mode based on quantizer state</span>

<span class="sd">        :param layer:  Qc Quantizer layer for recurrent module</span>
<span class="sd">        :param name:  layer name</span>
<span class="sd">        :return: True if the encoding is invalid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">output_quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Encoding for </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">: min=</span><span class="si">%f</span><span class="s2">, max=</span><span class="si">%f</span><span class="s2">, offset=</span><span class="si">%f</span><span class="s2">. delta=</span><span class="si">%f</span><span class="s2">, bw=</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
                                 <span class="n">name</span><span class="p">,</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                                 <span class="n">encoding</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">bw</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">input_quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">encoding</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Encoding for </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">: min=</span><span class="si">%f</span><span class="s2">, max=</span><span class="si">%f</span><span class="s2">, offset=</span><span class="si">%f</span><span class="s2">. delta=</span><span class="si">%f</span><span class="s2">, bw=</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
                                 <span class="n">name</span><span class="p">,</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                                 <span class="n">encoding</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">bw</span><span class="p">)</span>

        <span class="n">layer</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_percentile_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentile_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the percentile value to be used while computing encodings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">percentile_value</span> <span class="o">&lt;</span> <span class="mi">90</span> <span class="ow">or</span> <span class="n">percentile_value</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Percentile value must be in range [90, 100]&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_percentile_value</span> <span class="o">=</span> <span class="n">percentile_value</span>

<div class="viewcode-block" id="QuantizationSimModel.export"><a class="viewcode-back" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel.export">[docs]</a>    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
               <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">export_to_torchscript</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">use_embedded_encodings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method exports out the quant-sim model so it is ready to be run on-target.</span>

<span class="sd">        Specifically, the following are saved:</span>

<span class="sd">        1. The sim-model is exported to a regular PyTorch model without any simulation ops</span>
<span class="sd">        2. The quantization encodings are exported to a separate JSON-formatted file that can</span>
<span class="sd">           then be imported by the on-target runtime (if desired)</span>
<span class="sd">        3. Optionally, An equivalent model in ONNX format is exported. In addition, nodes in the ONNX model are named</span>
<span class="sd">           the same as the corresponding PyTorch module names. This helps with matching ONNX node to their quant</span>
<span class="sd">           encoding from #2.</span>

<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph. It is required for the dummy_input to</span>
<span class="sd">                be placed on CPU.</span>
<span class="sd">        :param onnx_export_args: Optional export argument with onnx specific overrides provided as a dictionary or</span>
<span class="sd">            OnnxExportApiArgs object. If not provided, defaults to &quot;opset_version&quot; = None, &quot;input_names&quot; = None,</span>
<span class="sd">            &quot;output_names&quot; = None, and for torch version &lt; 1.10.0, &quot;enable_onnx_checker&quot; = False.</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops. Defaults to False.</span>
<span class="sd">        :param export_to_torchscript: If True, export to torchscript. Export to onnx otherwise. Defaults to False.</span>
<span class="sd">        :param use_embedded_encodings: If True, another onnx model embedded with fakequant nodes will be exported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># save the quantized model and encodings</span>
        <span class="n">model_filename</span> <span class="o">=</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.pth&#39;</span>
        <span class="n">model_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">model_filename</span><span class="p">)</span>

        <span class="c1"># Create a version of the model without any quantization ops</span>
        <span class="n">model_to_export</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">get_original_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model_to_export</span><span class="p">,</span> <span class="n">model_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">onnx_export_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">onnx_export_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;opset_version&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="s1">&#39;input_names&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="s1">&#39;output_names&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1.10.0&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onnx_export_args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">onnx_export_args</span><span class="p">[</span><span class="s1">&#39;enable_onnx_checker&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">log_with_error_and_assert_if_false</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">onnx_export_args</span><span class="p">,</span> <span class="p">(</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)),</span>
                                           <span class="n">logger</span><span class="p">,</span>
                                           <span class="sa">f</span><span class="s1">&#39;unsupported opt_args type=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">onnx_export_args</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_embedded_encodings</span><span class="p">:</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">save_model_with_embedded_quantization_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span>
                                                                             <span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">export_to_torchscript</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">export_to_torchscript</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">export_torch_script_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">model_to_export</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                             <span class="n">dummy_input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">export_onnx_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">model_to_export</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                     <span class="n">dummy_input</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span><span class="p">,</span> <span class="n">quantizer_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quant_args</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">export_torch_script_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                                <span class="n">original_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                                                <span class="n">sim_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                                                <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                                                <span class="n">excluded_layer_names</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method exports a torchscript mode and the corresponding encodings</span>

<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param original_model: model without the quantsim wrappers</span>
<span class="sd">        :param sim_model: model with the quantsim wrappers</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph.</span>
<span class="sd">        :param excluded_layer_names: List of names of layers that have been excluded from quantization.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create torchscript model and obtain node to i/o tensor name map</span>
        <span class="n">ts_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.torchscript.pth&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">original_model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">torchscript_utils</span><span class="o">.</span><span class="n">create_torch_script_model</span><span class="p">(</span><span class="n">ts_path</span><span class="p">,</span> <span class="n">original_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>

            <span class="n">trace</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ts_path</span><span class="p">)</span>
            <span class="n">torch_script_node_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span> <span class="o">=</span> \
                <span class="n">torchscript_utils</span><span class="o">.</span><span class="n">get_node_to_io_tensor_names_map</span><span class="p">(</span><span class="n">original_model</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>

        <span class="c1"># Export encodings</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_export_encodings_to_files</span><span class="p">(</span><span class="n">sim_model</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span>
                                                        <span class="n">torch_script_node_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">,</span>
                                                        <span class="n">excluded_layer_names</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">export_onnx_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                                        <span class="n">sim_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                                        <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                        <span class="n">module_marker_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">is_conditional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">excluded_layer_names</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">quantizer_args</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method exports a onnx model and the corresponding encodings</span>

<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param original_model: model without the quantsim wrappers</span>
<span class="sd">        :param sim_model: model with the quantsim wrappers</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph.</span>
<span class="sd">        :param onnx_export_args: Additional onnx export args including export api overrides</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">               multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">               ops.</span>
<span class="sd">        :param module_marker_map: Maps module names to traced custom markers (only used for conditional models)</span>
<span class="sd">        :param is_conditional: True if model is conditional, False otherwise</span>
<span class="sd">        :param excluded_layer_names: List of names of layers that have been excluded from quantization.</span>
<span class="sd">        :return: None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="n">onnx_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.onnx&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1.13.0&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">onnx_utils</span><span class="o">.</span><span class="n">EXPORT_TO_ONNX_DIRECT</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Exporting quantsim using torch.onnx.export directly&#39;</span><span class="p">)</span>
            <span class="n">original_model</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">OnnxExportApiArgs</span><span class="p">):</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">onnx_export_args</span><span class="o">.</span><span class="n">kwargs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">onnx_export_args</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">onnx</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">original_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span> <span class="n">onnx_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create onnx model and obtain node to i/o tensor name map</span>
            <span class="n">OnnxSaver</span><span class="o">.</span><span class="n">create_onnx_model_with_pytorch_layer_names</span><span class="p">(</span><span class="n">onnx_path</span><span class="p">,</span> <span class="n">original_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span> <span class="n">is_conditional</span><span class="p">,</span>
                                                                 <span class="n">module_marker_map</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">)</span>

        <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">onnx_path</span><span class="p">)</span>
        <span class="n">onnx_node_to_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span> <span class="o">=</span> <span class="n">OnnxSaver</span><span class="o">.</span><span class="n">get_onnx_node_to_io_tensor_names_map</span><span class="p">(</span><span class="n">onnx_model</span><span class="p">)</span>

        <span class="c1"># Export encodings</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_export_encodings_to_files</span><span class="p">(</span><span class="n">sim_model</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span>
                                                        <span class="n">onnx_node_to_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">,</span>
                                                        <span class="n">excluded_layer_names</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">,</span>
                                                        <span class="n">quantizer_args</span><span class="o">=</span><span class="n">quantizer_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save_encodings_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save encodings in the model to json.</span>

<span class="sd">        :param path: Path to save file</span>
<span class="sd">        :param filename_prefix: Filename to use for saved file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">activation_encodings</span><span class="p">,</span> <span class="n">param_encodings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_activation_param_encodings</span><span class="p">()</span>
        <span class="n">encodings_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;activation_encodings&#39;</span><span class="p">:</span> <span class="n">activation_encodings</span><span class="p">,</span> <span class="s1">&#39;param_encodings&#39;</span><span class="p">:</span> <span class="n">param_encodings</span><span class="p">}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.json&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">encoding_json</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">encodings_dict</span><span class="p">,</span> <span class="n">encoding_json</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_activation_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get activation and param encodings from sim.model.</span>

<span class="sd">        :return: Tuple of activation and param encodings dictionaries mapping torch module names to encodings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">activation_encodings</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">param_encodings</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">export_input_encodings</span><span class="p">()):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">encoding</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">export_output_encodings</span><span class="p">()):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">encoding</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">export_param_encodings</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">encoding</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">param_encodings</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>

        <span class="k">return</span> <span class="n">activation_encodings</span><span class="p">,</span> <span class="n">param_encodings</span>

    <span class="k">def</span> <span class="nf">exclude_layers_from_quantization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layers_to_exclude</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Excludes certain layers from being quantized-dequantized by the simulator</span>
<span class="sd">        :param layers_to_exclude: List of torch layers to exclude</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Save the excluded layer names. Do not save the modules since the wrapper removal depends on</span>
        <span class="c1"># reference count to automatically remove the layers.</span>
        <span class="n">module_to_name_dict</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_module_to_name_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">quant_layers_to_exclude</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">quant_cls</span> <span class="o">=</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span>
                     <span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
                     <span class="n">LazyQuantizeWrapper</span><span class="p">,</span>
                     <span class="n">BaseQuantizationMixin</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">layers_to_exclude</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">quant_cls</span><span class="p">):</span>
                    <span class="n">quant_layers_to_exclude</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
                    <span class="n">excluded_module_name</span> <span class="o">=</span> <span class="n">module_to_name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">excluded_module_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_quantization_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">quant_layers_to_exclude</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exclude_param_from_quantization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name_to_exclude</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Excludes all parameters matching &#39;param_name&#39; from quantization</span>
<span class="sd">        :param param_name_to_exclude: Name of the parameter to exclude</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">param_name_to_exclude</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="n">param_name_to_exclude</span><span class="p">]</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">BaseQuantizationMixin</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">param_name_to_exclude</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="n">param_name_to_exclude</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_replace_quantization_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively remove quantization wrappers from all appropriate modules starting with a given module</span>
<span class="sd">        :param model: model for which PostTrainingWrapper gets replaced with Trainable wrapped module</span>
<span class="sd">        :param device: device on which model is present</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">StaticGridQuantWrapper</span><span class="p">):</span>
                <span class="c1"># Create a Trainable wrapper and copy properties of PostTrainingWrapper to the Trainable wrapper</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_and_initialize_trainable_wrapper</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                <span class="c1"># Set Recurrent layer for training mode</span>
                <span class="n">module_ref</span><span class="o">.</span><span class="n">construct_and_initialize_trainable_quantizers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span><span class="p">)</span>

            <span class="c1"># Recursively call children modules if present</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replace_quantization_wrapper</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_and_initialize_trainable_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_training_module</span><span class="p">:</span> <span class="n">StaticGridQuantWrapper</span><span class="p">,</span>
                                                    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LearnedGridQuantWrapper</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies following tensor quantizer attributes from StaticGridQuantWrapper to LearnedGridQuantWrapper</span>
<span class="sd">        to avoid any mismatch.</span>
<span class="sd">            - enabled</span>
<span class="sd">            - bitwidth</span>
<span class="sd">            - encoding</span>
<span class="sd">            - use_symmetric_encodings</span>
<span class="sd">            - use_strict_symmetric</span>
<span class="sd">            - use_unsigned_symmetric</span>

<span class="sd">        :param post_training_module: StaticGridQuantWrapper wrapped module</span>
<span class="sd">        :param device: device on which model is present</span>
<span class="sd">        :return: trainable_module: QcTrainable wrapper module</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">post_training_module</span><span class="o">.</span><span class="n">_module_to_wrap</span>

        <span class="n">num_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">)</span>
        <span class="n">num_outputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">)</span>

        <span class="c1"># Creating a LearnedGridQuantWrapper module</span>
        <span class="n">trainable_module</span> <span class="o">=</span> <span class="n">LearnedGridQuantWrapper</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_param_bw</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rounding_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span><span class="p">,</span>
                                                   <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">num_inputs</span><span class="o">=</span><span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="n">num_outputs</span><span class="p">,</span>
                                                   <span class="n">data_type</span><span class="o">=</span><span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># Copy user settable attributes for outputs</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">):</span>
            <span class="n">initialize_learned_grid_quantizer_attributes</span><span class="p">(</span><span class="n">trainable_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">quantizer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trainable_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">encoding_min_max_fixed_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trainable_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">freeze_encoding</span><span class="p">()</span>
        <span class="c1"># Copy user settable attributes for inputs</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">):</span>
            <span class="n">initialize_learned_grid_quantizer_attributes</span><span class="p">(</span><span class="n">trainable_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">quantizer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trainable_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">encoding_min_max_fixed_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trainable_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">freeze_encoding</span><span class="p">()</span>
        <span class="c1"># Copy user settable attributes for params</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">post_training_module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">learned_grid_quantizer</span> <span class="o">=</span> <span class="n">trainable_module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">initialize_learned_grid_quantizer_attributes</span><span class="p">(</span><span class="n">learned_grid_quantizer</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">learned_grid_quantizer</span><span class="o">.</span><span class="n">encoding_min_max_fixed_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">learned_grid_quantizer</span><span class="o">.</span><span class="n">freeze_encoding</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">trainable_module</span>

    <span class="k">def</span> <span class="nf">replace_wrappers_for_quantize_dequantize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces StaticGridWrapper with LearnedGridWrapper</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_init</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> \
                <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_enhanced_init</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">device</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># Model doesn&#39;t have any parameter.</span>
                <span class="c1"># Set device to cpu by default.</span>
                <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_replace_quantization_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_override_quant_config_for_transformer_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks for specific ops in a transformer and overrides the quantizer to tf mode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">attention_with_mask_add_quantizer_dict</span> <span class="o">=</span> <span class="n">transformer_utils</span><span class="o">.</span><span class="n">get_attention_with_mask_add_quantizer_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attention_head</span><span class="p">,</span> <span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="p">,</span> <span class="n">mask_add_name</span><span class="p">)</span> <span class="ow">in</span> <span class="n">attention_with_mask_add_quantizer_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="p">,</span> <span class="p">(</span><span class="n">StaticGridQuantWrapper</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">))</span>

            <span class="c1"># clamping needs to be done only if data type is int</span>
            <span class="k">if</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span> <span class="ow">and</span> \
                    <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">:</span>

                <span class="n">module_to_quantize</span> <span class="o">=</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">_module_to_wrap</span>

                <span class="n">quantizer_wrapper_type</span> <span class="o">=</span> <span class="n">qc_quantize_modules_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">),</span> <span class="n">LazyQuantizeWrapper</span><span class="p">)</span>

                <span class="c1"># Add a quantizer set to tf mode and bw to 16 and copy over remaining attributes</span>
                <span class="c1"># we need 16 bit to retain the max representation for this quantizer.</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="n">quantizer_wrapper_type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>
                                                          <span class="n">MAP_PYMO_TO_ROUND_MODE</span><span class="p">[</span><span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">round_mode</span><span class="p">],</span>
                                                          <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span><span class="p">,</span>
                                                          <span class="n">num_inputs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">),</span>
                                                          <span class="n">num_outputs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">),</span>
                                                          <span class="n">data_type</span><span class="o">=</span><span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>

                <span class="nb">setattr</span><span class="p">(</span><span class="n">attention_head</span><span class="p">,</span> <span class="n">mask_add_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clamp_transformer_attention_mask_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        clamps the quantizer encoding min associated with mask adder</span>
<span class="sd">        op within a attention head.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">attention_with_mask_add_quantizer_dict</span> <span class="o">=</span> <span class="n">transformer_utils</span><span class="o">.</span><span class="n">get_attention_with_mask_add_quantizer_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">attention_with_mask_add_quantizer_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># we check if quantizer is enabled and data type is set to int before clamping</span>
            <span class="c1"># clamping is not necessary for FP16 mode.</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="p">,</span> <span class="n">StaticGridQuantWrapper</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span> <span class="ow">and</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">enabled</span> \
                    <span class="ow">and</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">output_quantizer</span> <span class="ow">in</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">:</span>
                    <span class="c1"># get the min/max from accumulated stats associated with this quantizer</span>
                    <span class="k">if</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">is_encoding_frozen</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span>
                    <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">encoding</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
                                                        <span class="n">transformer_utils</span><span class="o">.</span><span class="n">MASK_OVERRIDE_VALUE</span><span class="p">)</span>
                    <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span>

                    <span class="c1"># recompute grid params as we clamped min and updated max above</span>
                    <span class="c1"># with bitwidth as dictated by default config</span>
                    <span class="n">clamped_encoding</span> <span class="o">=</span> <span class="n">aimet_common</span><span class="o">.</span><span class="n">quantsim</span><span class="o">.</span><span class="n">recompute_grid_params</span><span class="p">(</span>
                        <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span><span class="p">,</span>
                        <span class="n">output_quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span><span class="p">)</span>

                    <span class="c1"># update encoding of this quantizer</span>
                    <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">clamped_encoding</span>
                    <span class="n">output_quantizer</span><span class="o">.</span><span class="n">freeze_encoding</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping clamp on </span><span class="si">%s</span><span class="s2">. Quantizer is disabled or not int type&quot;</span><span class="p">,</span>
                             <span class="n">mask_add_quantizer_wrapper</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_quantsim_inputs</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="p">],</span> <span class="n">rounding_mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                  <span class="n">default_param_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span> <span class="o">=</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform sanity checks on inputs to QuantSim</span>

<span class="sd">        NOTE: This method will be deprecated.</span>
<span class="sd">              Call aimet_common.quantsim.validate_quantsim_inputs directly instead.</span>

<span class="sd">        :param quant_scheme: Quantization scheme. Supported options are &#39;tf_enhanced&#39; or &#39;tf&#39; or using Quant Scheme Enum</span>
<span class="sd">                             QuantScheme.post_training_tf or QuantScheme.post_training_tf_enhanced</span>
<span class="sd">        :param rounding_mode: Rounding mode. Supported options are &#39;nearest&#39; or &#39;stochastic&#39;</span>
<span class="sd">        :param default_output_bw: Default bitwidth (4-31) to use for quantizing layer inputs and outputs</span>
<span class="sd">        :param default_param_bw: Default bitwidth (4-31) to use for quantizing layer parameters</span>
<span class="sd">        :param data_type: Data type of the quantized values (int or float).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_quantsim_inputs</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span>
                                 <span class="n">rounding_mode</span><span class="p">,</span>
                                 <span class="n">default_output_bw</span><span class="p">,</span>
                                 <span class="n">default_param_bw</span><span class="p">,</span>
                                 <span class="n">data_type</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_next_downstream_modules</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
        <span class="n">downstream_modules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">succeeding_op</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">consumers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">succeeding_op</span><span class="o">.</span><span class="n">get_module</span><span class="p">():</span>
                <span class="n">downstream_modules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">succeeding_op</span><span class="o">.</span><span class="n">get_module</span><span class="p">())</span>

            <span class="k">elif</span> <span class="n">succeeding_op</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CG_SPLIT</span><span class="p">:</span>
                <span class="n">downstream_modules</span> <span class="o">+=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_find_next_downstream_modules</span><span class="p">(</span><span class="n">succeeding_op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">downstream_modules</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_export_encodings_to_files</span><span class="p">(</span><span class="n">sim_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                   <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">excluded_layer_names</span><span class="p">,</span>
                                   <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">quantizer_args</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the quantized model weight encodings</span>

<span class="sd">        :param sim_model: Quantsim model to export encodings for</span>
<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: filename to store exported weight encodings in json format</span>
<span class="sd">        :param op_to_io_tensor_map: Dictionary of layer to I/O tensor mapping from onnx or torch script model</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        :param excluded_layer_names: List of names of layers that have been excluded from quantization.</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :param quantizer_args</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=too-many-locals</span>

        <span class="c1"># Create a dictionary to export to JSON</span>
        <span class="n">activation_encodings_onnx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">activation_encodings_torch</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">param_encodings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">layers_to_onnx_op_names</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_layers_in_io_tensor_map</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">)</span>
        <span class="n">tensor_to_consumer_map</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_tensor_to_consumer_map</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">)</span>
        <span class="n">layer_names_not_found</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">sim_model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="p">(</span><span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">has_valid_encodings</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># TODO: specifically call out dropout layers here since they are specifically switched out during export.</span>
            <span class="c1"># These ops should eventually be reworked as part of math invariant ops to ignore quantization altogether.</span>
            <span class="c1"># pylint: disable=protected-access</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">get_original_module</span><span class="p">(),</span> <span class="n">utils</span><span class="o">.</span><span class="n">DROPOUT_TYPES</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">layers_to_onnx_op_names</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">layer_names_not_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dicts_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                      <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                                                      <span class="n">param_encodings</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                      <span class="n">valid_param_set</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">,</span>
                                                                      <span class="n">tensor_to_consumer_map</span><span class="p">,</span> <span class="n">layers_to_onnx_op_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">layer_names_not_found</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The following layers were not found in the exported onnx model. Encodings for these layers&quot;</span>
                           <span class="s2">&quot; will not appear in the exported encodings file:</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;This can be due to several reasons:</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">- The layer is set to quantize with float datatype, but was not exercised in compute &quot;</span>
                           <span class="s2">&quot;encodings. Not an issue if the layer is not meant to be run.</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">- The layer has valid encodings but was not seen while exporting to onnx using the dummy &quot;</span>
                           <span class="s2">&quot;input provided in sim.export(). Ensure that the dummy input covers all layers.&quot;</span><span class="p">,</span>
                           <span class="n">layer_names_not_found</span><span class="p">)</span>
        <span class="n">encodings_dict_onnx</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="n">encoding_version</span><span class="p">,</span>
                               <span class="s1">&#39;activation_encodings&#39;</span><span class="p">:</span> <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                               <span class="s1">&#39;param_encodings&#39;</span><span class="p">:</span> <span class="n">param_encodings</span><span class="p">,</span>
                               <span class="s1">&#39;excluded_layers&#39;</span><span class="p">:</span> <span class="n">excluded_layer_names</span><span class="p">}</span>

        <span class="n">encodings_dict_pytorch</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="n">encoding_version</span><span class="p">,</span>
                                  <span class="s1">&#39;activation_encodings&#39;</span><span class="p">:</span> <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                  <span class="s1">&#39;param_encodings&#39;</span><span class="p">:</span> <span class="n">param_encodings</span><span class="p">,</span>
                                  <span class="s1">&#39;excluded_layers&#39;</span><span class="p">:</span> <span class="n">excluded_layer_names</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">quantizer_args</span><span class="p">:</span>
            <span class="n">encodings_dict_pytorch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;quantizer_args&#39;</span><span class="p">:</span> <span class="n">quantizer_args</span><span class="p">})</span>
            <span class="n">encodings_dict_onnx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;quantizer_args&#39;</span><span class="p">:</span> <span class="n">quantizer_args</span><span class="p">})</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Layers excluded from quantization: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">excluded_layer_names</span><span class="p">)</span>

        <span class="c1"># export weight encodings to output json file</span>
        <span class="n">encoding_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.encodings&#39;</span><span class="p">)</span>
        <span class="n">encoding_file_path_pytorch</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;_torch&#39;</span> <span class="o">+</span> <span class="s1">&#39;.encodings&#39;</span><span class="p">)</span>
        <span class="n">save_json_yaml</span><span class="p">(</span><span class="n">encoding_file_path</span><span class="p">,</span> <span class="n">encodings_dict_onnx</span><span class="p">)</span>
        <span class="n">save_json_yaml</span><span class="p">(</span><span class="n">encoding_file_path_pytorch</span><span class="p">,</span> <span class="n">encodings_dict_pytorch</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_tensor_to_consumer_map</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dictionary mapping tensor names to names of ops consuming that tensor.</span>

<span class="sd">        :param op_to_io_tensor_map: Dictionary mapping op names to IO Tensors</span>
<span class="sd">        :return: Dictionary mapping tensor names to names of ops consuming that tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tensor_to_consumer_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1.13.0&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">onnx_utils</span><span class="o">.</span><span class="n">EXPORT_TO_ONNX_DIRECT</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">io_tensors</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">io_tensors</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">inp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tensor_to_consumer_map</span><span class="p">:</span>
                        <span class="n">tensor_to_consumer_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tensor_to_consumer_map</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">io_tensors</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">output</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tensor_to_consumer_map</span><span class="p">:</span>
                        <span class="n">tensor_to_consumer_map</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">tensor_to_consumer_map</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_layers_in_io_tensor_map</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        extract root(layer) names of onnx op names in tensor map</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :return: a set containing layer names present in io tensor map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">layers_to_onnx_op_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1.13.0&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">onnx_utils</span><span class="o">.</span><span class="n">EXPORT_TO_ONNX_DIRECT</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">modified_name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">if</span> <span class="n">modified_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.end&#39;</span><span class="p">):</span>
                    <span class="n">modified_name</span> <span class="o">=</span> <span class="n">modified_name</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">layers_to_onnx_op_names</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">layers_to_onnx_op_names</span><span class="p">[</span><span class="n">modified_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">layers_to_onnx_op_names</span><span class="p">[</span><span class="n">modified_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">pytorch_name</span> <span class="o">=</span> <span class="n">get_pytorch_name_from_onnx_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pytorch_name</span> <span class="ow">in</span> <span class="n">layers_to_onnx_op_names</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">layers_to_onnx_op_names</span><span class="p">[</span><span class="n">pytorch_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">layers_to_onnx_op_names</span><span class="p">[</span><span class="n">pytorch_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">layers_to_onnx_op_names</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_param_encodings_dict_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                               <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name : Name of the layer</span>
<span class="sd">        :param param_encodings: dictionary of param encodings</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">orig_param_name</span><span class="p">,</span> <span class="n">param_encoding</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">export_param_encodings</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">param_name</span> <span class="o">=</span> <span class="n">layer_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">orig_param_name</span>
            <span class="k">if</span> <span class="n">param_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_param_set</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Param tensor {</span><span class="si">%s</span><span class="s1">} not found in valid param set&#39;</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">param_encodings</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_encoding</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dicts_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                         <span class="n">activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                         <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                         <span class="n">tensor_to_consumer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                                         <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add given layer param and activation encodings to respective dictionaries to be used for exporting encodings</span>
<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name: Name of the layer</span>
<span class="sd">        :param activation_encodings_onnx: dictionary of activation encodings which maps onnx attribute to encodings</span>
<span class="sd">        :param activation_encodings_torch: dictionary of activation encodings which maps pytorch names to encodings</span>
<span class="sd">        :param param_encodings: dictionary of param encodings</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :param tensor_to_consumer_map: Dictionary mapping tensor names to op names which consume the tensor</span>
<span class="sd">        :param layers_to_onnx_op_names: Dictionary mapping PyTorch layer names to names of corresponding ONNX ops</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>

            <span class="c1"># --------------------------------------</span>
            <span class="c1"># Update encodings for Input activations</span>
            <span class="c1"># --------------------------------------</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dict_for_input_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                             <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                             <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                                                             <span class="n">layers_to_onnx_op_names</span><span class="p">)</span>
            <span class="c1"># ---------------------------------------</span>
            <span class="c1"># Update encodings for output activations</span>
            <span class="c1"># ---------------------------------------</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dict_for_output_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span>
                                                                              <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                              <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                              <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                                                              <span class="n">propagate_encodings</span><span class="p">,</span>
                                                                              <span class="n">tensor_to_consumer_map</span><span class="p">,</span>
                                                                              <span class="n">layers_to_onnx_op_names</span><span class="p">)</span>
            <span class="c1"># ---------------------------</span>
            <span class="c1"># Update encodings for Params</span>
            <span class="c1"># ---------------------------</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_param_encodings_dict_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">,</span>
                                                                        <span class="n">valid_param_set</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
            <span class="c1"># Update encodings for Recurrent layers</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dict_for_recurrent_layers</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                            <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                            <span class="n">param_encodings</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">find_op_names_for_layer</span><span class="p">(</span><span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                <span class="n">tensor_to_consumer_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
                                <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the last ONNX op and the list of ONNX Ops that were mapped from a PyTorch Op.</span>

<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :param tensor_to_consumer_map: Dictionary mapping tensor names to op names which consume the tensor</span>
<span class="sd">        :param layers_to_onnx_op_names: Dictionary mapping PyTorch layer names to names of corresponding ONNX ops</span>
<span class="sd">        :return: tuple(end op names, all op names)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1.13.0&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">onnx_utils</span><span class="o">.</span><span class="n">EXPORT_TO_ONNX_DIRECT</span><span class="p">:</span>
            <span class="n">op_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">layer_name</span><span class="o">+</span><span class="s1">&#39;#&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="n">layer_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">op_names</span><span class="p">,</span> <span class="n">op_names</span>

            <span class="n">end_op_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">op_name</span> <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span> <span class="k">if</span> <span class="n">op_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.end&#39;</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">end_op_names</span><span class="p">,</span> <span class="n">op_names</span>

        <span class="k">assert</span> <span class="n">tensor_to_consumer_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">layers_to_onnx_op_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="c1"># Get all ops which correspond to the current PyTorch layer being processed.</span>
        <span class="n">op_names</span> <span class="o">=</span> <span class="n">layers_to_onnx_op_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">op_name_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">op_names</span><span class="p">)</span>

        <span class="n">end_op_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">end_op_names_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
            <span class="c1"># Loop through outputs of each op and check whether the output leads to an op not in</span>
            <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">tensor_to_consumer_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tensor_to_consumer_map</span><span class="p">[</span><span class="n">output</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">op_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">end_op_names_set</span><span class="p">:</span>
                        <span class="c1"># output has no consumers, and can either be a model output or an unused op output.</span>
                        <span class="c1"># List it as an end_op_name all the same.</span>
                        <span class="n">end_op_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
                        <span class="n">end_op_names_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">consumer</span> <span class="ow">in</span> <span class="n">tensor_to_consumer_map</span><span class="p">[</span><span class="n">output</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">consumer</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op_name_set</span> <span class="ow">and</span> <span class="n">op_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">end_op_names_set</span><span class="p">:</span>
                            <span class="n">end_op_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
                            <span class="n">end_op_names_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">end_op_names</span><span class="p">,</span> <span class="n">op_names</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dict_for_output_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                     <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                     <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">tensor_to_consumer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                                                     <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="n">output_tensors</span><span class="p">,</span> <span class="n">propagate_tensors</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_layer_activation_tensors</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span>
                                                                                               <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                                               <span class="n">tensor_to_consumer_map</span><span class="p">,</span>
                                                                                               <span class="n">layers_to_onnx_op_names</span><span class="p">)</span>
        <span class="n">output_encodings</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">export_output_encodings</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_encodings</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;number of output quantizers: </span><span class="si">%d</span><span class="s2"> available for layer: </span><span class="si">%s</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;doesn&#39;t match with number of output tensors: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_encodings</span><span class="p">),</span> <span class="n">layer_name</span><span class="p">,</span>
                           <span class="nb">len</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">output_tensor</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">,</span> <span class="n">output_encodings</span><span class="p">)):</span>

            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">output_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>
                <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">QUANTIZER_TYPE_OUTPUT</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_OUTPUT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_OUTPUT</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">propagate_encodings</span><span class="p">:</span>
            <span class="n">valid_encodings</span> <span class="o">=</span> <span class="p">[</span><span class="n">enc</span> <span class="k">for</span> <span class="n">enc</span> <span class="ow">in</span> <span class="n">output_encodings</span> <span class="k">if</span> <span class="n">enc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">valid_encodings</span><span class="p">:</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="n">valid_encodings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">activation_tensor</span> <span class="ow">in</span> <span class="n">propagate_tensors</span><span class="p">:</span>
                    <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">activation_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_propagated_encoding_dict</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dict_for_input_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                    <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                    <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="n">input_encodings</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">export_input_encodings</span><span class="p">()</span>
        <span class="c1"># skip layer if it has no input encodings.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">input_encodings</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">input_tensors</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_layer_input_tensors</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                      <span class="n">layers_to_onnx_op_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_encodings</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;number of input quantizers: </span><span class="si">%d</span><span class="s2"> available for layer: </span><span class="si">%s</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;doesn&#39;t match with number of input tensors: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_encodings</span><span class="p">),</span> <span class="n">layer_name</span><span class="p">,</span>
                           <span class="nb">len</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">input_tensor</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">,</span> <span class="n">input_encodings</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">input_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>
                <span class="c1"># Check if layer exists in the pytorch encoding dictionary</span>
                <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">QUANTIZER_TYPE_INPUT</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># Store encodings for a particular index so that they can be used to check if a quantizer was</span>
                <span class="c1"># enabled or not</span>
                <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_layer_input_tensors</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                 <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the list of input tensor names mapped from a PyTorch Op.</span>

<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :param layers_to_onnx_op_names: Dictionary mapping PyTorch layer names to names of corresponding ONNX ops</span>
<span class="sd">        :return: list of input tensor names.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">param_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">param_name</span> <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1.13.0&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">onnx_utils</span><span class="o">.</span><span class="n">EXPORT_TO_ONNX_DIRECT</span><span class="p">:</span>
            <span class="n">start_op_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span>
                              <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;#0&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">)</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="n">layer_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">layers_to_onnx_op_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">op_names</span> <span class="o">=</span> <span class="n">layers_to_onnx_op_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">op_name_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">op_names</span><span class="p">)</span>
            <span class="n">start_op_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
                <span class="c1"># For each op&#39;s inputs, if the input comes from an op not associated with this layer, add it to</span>
                <span class="c1"># start_op_names.</span>
                <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">inp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op_name_set</span><span class="p">:</span>
                        <span class="n">start_op_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>

        <span class="n">input_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">input_tensors_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">start_op_names</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">input_tensor</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">input_tensor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param_inputs</span> <span class="ow">and</span> <span class="n">input_tensor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_tensors_set</span><span class="p">:</span>
                    <span class="n">input_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>
                    <span class="n">input_tensors_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">input_tensors</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_layer_activation_tensors</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                      <span class="n">tensor_to_consumer_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">layers_to_onnx_op_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the list of output tensor and intermediate tensor names mapped from a PyTorch Op.</span>

<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :param tensor_to_consumer_map: Dictionary mapping tensor names to op names which consume the tensor</span>
<span class="sd">        :param layers_to_onnx_op_names: Dictionary mapping PyTorch layer names to names of corresponding ONNX ops</span>
<span class="sd">        :return: tuple containing list of output tensor names and list of intermediate tensors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">end_op_names</span><span class="p">,</span> <span class="n">op_names</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">find_op_names_for_layer</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span> <span class="n">tensor_to_consumer_map</span><span class="p">,</span>
                                                             <span class="n">layers_to_onnx_op_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output_op_map_str</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_output_map_str</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;layer_name: </span><span class="si">%s</span><span class="s2">, has multiple output onnx ops: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">output_op_map_str</span><span class="p">)</span>

        <span class="n">output_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">intermediate_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">end_op_names</span><span class="p">:</span>
                <span class="n">output_tensors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intermediate_tensors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output_tensors</span><span class="p">,</span> <span class="n">intermediate_tensors</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_output_map_str</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns formatted list of output ops tensor mapping</span>

<span class="sd">        :param end_op_names: list of output onnx ops</span>
<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :return: formatted string with output ops and their corresponding output count.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_output_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">)</span>
        <span class="n">op_map_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                               <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">end_op_names</span><span class="p">[:</span><span class="mi">5</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">num_output_ops</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">op_map_str</span> <span class="o">+=</span> <span class="s1">&#39;, ..&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">num_output_ops</span><span class="si">}</span><span class="s1">,[</span><span class="si">{</span><span class="n">op_map_str</span><span class="si">}</span><span class="s1">]&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dict_for_recurrent_layers</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                   <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                   <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param layer:</span>
<span class="sd">        :param layer_name:</span>
<span class="sd">        :param op_to_io_tensor_map:</span>
<span class="sd">        :param activation_encodings_onnx:</span>
<span class="sd">        :param param_encodings:</span>
<span class="sd">        :param propagate_encodings:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=too-many-nested-blocks</span>
        <span class="c1"># pylint: disable=too-many-locals</span>

        <span class="n">onnx_activations_to_quantizers</span><span class="p">,</span> <span class="n">onnx_params_to_quantizers</span> <span class="o">=</span> \
            <span class="n">layer</span><span class="o">.</span><span class="n">get_activation_param_quantizers_for_onnx_tensors</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">layer_name</span> <span class="o">+</span>
                                                                                       <span class="s1">&#39;#root_node&#39;</span><span class="p">])</span>
        <span class="c1"># ------------------</span>
        <span class="c1"># Activations</span>
        <span class="c1"># ------------------</span>
        <span class="n">quantizer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">onnx_activations_to_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span>
                                                                  <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">propagate_encodings</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">op_names</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">find_op_names_for_layer</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
                <span class="n">io_tensor_list</span> <span class="o">=</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">io_tensor_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">io_tensor_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">io_tensor_list</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">io_tensors</span> <span class="ow">in</span> <span class="n">io_tensor_list</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">io_tensors</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">output_tensor</span> <span class="ow">in</span> <span class="n">io_tensors</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">output_tensor</span> <span class="ow">in</span> <span class="n">onnx_activations_to_quantizers</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
                            <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span>
                                                                                  <span class="kc">True</span><span class="p">)</span>

                            <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">output_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>

        <span class="c1"># ------------------</span>
        <span class="c1"># Params</span>
        <span class="c1"># ------------------</span>
        <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">onnx_params_to_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span>
                                                                  <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">param_encodings</span><span class="p">[</span><span class="n">tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_qc_quantized_layers</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">]]:</span>
        <span class="n">quantized_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">,</span> <span class="n">BaseQuantizationMixin</span><span class="p">)):</span>
                <span class="n">quantized_layers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">module</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">quantized_layers</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_quantizable_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function to check if a module is eligible for quantization.</span>
<span class="sd">            If the module is NOT an PyTorch module type or if the module was already</span>
<span class="sd">            Quantized or if the module is in the layers_to_ignore list, don&#39;t quantize.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">unquantizable_modules</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Module </span><span class="si">%s</span><span class="s2"> not quantizable&quot;</span><span class="p">,</span> <span class="n">module_ref</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Module </span><span class="si">%s</span><span class="s2"> is quantizable&quot;</span><span class="p">,</span> <span class="n">module_ref</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_create_quantizer_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_to_quantize</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                 <span class="n">data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiates wrapper based on quant scheme</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="ow">in</span> <span class="p">[</span><span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                                      <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_enhanced_init</span><span class="p">,</span>
                                      <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_init</span><span class="p">,</span>
                                      <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span><span class="p">]</span>

        <span class="c1"># We lookup the number of input and output tensors already determined</span>
        <span class="c1"># Special case, we are adding a wrapper for a module not in the forward pass: Use default of 1, 1</span>
        <span class="n">num_in_tensors</span><span class="p">,</span> <span class="n">num_out_tensors</span> <span class="o">=</span> <span class="n">num_inout_tensors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Set quantizer to be a module replacer if it is in qc_quantize_modules_dict, otherwise set as</span>
        <span class="c1"># StaticGridQuantWrapper.</span>
        <span class="n">quantizer_wrapper_type</span> <span class="o">=</span> <span class="n">qc_quantize_modules_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">),</span> <span class="n">LazyQuantizeWrapper</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">quantizer_wrapper_type</span> <span class="o">==</span> <span class="n">LazyQuantizeWrapper</span><span class="p">:</span>
            <span class="n">quant_scheme_for_initialization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">quant_scheme_for_initialization</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_v1_quant_scheme_for_initialization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span><span class="p">)</span>

        <span class="c1"># TODO add quant_scheme_for_initialization for FP8 case</span>
        <span class="n">quantized_module</span> <span class="o">=</span> <span class="n">quantizer_wrapper_type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_param_bw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_rounding_mode</span><span class="p">,</span> <span class="n">quant_scheme_for_initialization</span><span class="p">,</span> <span class="n">num_inputs</span><span class="o">=</span><span class="n">num_in_tensors</span><span class="p">,</span>
                                                  <span class="n">num_outputs</span><span class="o">=</span><span class="n">num_out_tensors</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">quantized_module</span>

    <span class="k">def</span> <span class="nf">_add_quantization_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursively add quantization wrappers to all appropriate modules starting with module</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;nn.Module found : </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">module_ref</span><span class="p">)</span>

            <span class="c1"># check if the module already quantized then ignore</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_quantizable_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># check if the module is leaf or not</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>

                <span class="c1"># Create a new QcQuantize wrapper module</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_quantizer_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>

                <span class="nb">setattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>

            <span class="c1"># recursively call children modules</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_quantization_wrappers</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_tensor_quantizers_for_consts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify and set is_const for tensor quantizers which correspond to constant inputs in the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">qc_quantize_wrapper</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant_wrappers</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_wrapper</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">)):</span>
                    <span class="c1"># Only handling QcQuantWrappers and not QcQuantizeRecurrents</span>
                    <span class="c1"># pylint: disable=protected-access</span>
                    <span class="n">conn_graph_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="o">.</span><span class="n">_module_to_op_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">qc_quantize_wrapper</span><span class="o">.</span><span class="n">_module_to_wrap</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">conn_graph_op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">input_quantizer</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qc_quantize_wrapper</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">,</span> <span class="n">conn_graph_op</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                            <span class="n">input_quantizer</span><span class="o">.</span><span class="n">is_const</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">is_const</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_encoding_dict</span><span class="p">(</span><span class="n">encoding</span><span class="p">:</span> <span class="n">libpymo</span><span class="o">.</span><span class="n">TfEncoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create encoding dictionary from encoding object</span>
<span class="sd">        :param encoding: Encoding of the quantizer</span>
<span class="sd">        :param quantizer: Tensor Quantizer</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :return: Encoding Dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">create_encoding_dict</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_remove_quantization_wrappers</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">starting_module</span><span class="p">,</span> <span class="n">list_of_modules_to_exclude</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively remove quantization wrappers from all appropriate modules starting with a given module</span>
<span class="sd">        :param starting_module: Module to recursive search downstream from</span>
<span class="sd">        :param list_of_modules_to_exclude: List of torch modules to remove quantization wrappers from (if present)</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">starting_module</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>

            <span class="c1"># If modules is in the exclude list, remove the wrapper</span>
            <span class="k">if</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">list_of_modules_to_exclude</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                    <span class="c1"># Remove the wrapper, gets auto-deleted</span>
                    <span class="c1"># pylint: disable=protected-access</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span><span class="o">.</span><span class="n">get_original_module</span><span class="p">())</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeStandAloneBase</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">())</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                    <span class="n">module_ref</span><span class="o">.</span><span class="n">update_params</span><span class="p">()</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span><span class="o">.</span><span class="n">module_to_quantize</span><span class="p">)</span>

            <span class="c1"># Recursively call children modules if present</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_remove_quantization_wrappers</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">list_of_modules_to_exclude</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_original_model</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the model with all quantization wrappers removed.</span>
<span class="sd">        :return: Model without quantization wrappers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">original_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="c1"># pylint: disable=unnecessary-comprehension</span>
        <span class="n">all_modules_in_original_model</span> <span class="o">=</span> <span class="p">[</span><span class="n">module</span> <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">original_model</span><span class="o">.</span><span class="n">modules</span><span class="p">()]</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_remove_quantization_wrappers</span><span class="p">(</span><span class="n">original_model</span><span class="p">,</span> <span class="n">all_modules_in_original_model</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">original_model</span>

    <span class="k">def</span> <span class="nf">_get_leaf_module_to_name_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a mapping from leaf modules to module name, where any ExportableQuantModule is considered a leaf module,</span>
<span class="sd">        and is therefore not further recursed (since we do not want to retrieve all internal quantizers/modules).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">recursively_populate_map</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_map</span><span class="p">,</span> <span class="n">start_str</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">starting_module</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">)</span> <span class="ow">or</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
                    <span class="n">module_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_str</span> <span class="o">+</span> <span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">recursively_populate_map</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">module_map</span><span class="p">,</span> <span class="n">start_str</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">module_to_name_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">recursively_populate_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">module_to_name_map</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">module_to_name_map</span>

    <span class="k">def</span> <span class="nf">_add_inputs_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">module_to_name_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_leaf_module_to_name_map</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">inputs_hook</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
            <span class="c1"># Need to remove hook here, otherwise the jit trace of CustomMarker with module ref will error since the</span>
            <span class="c1"># hook will be recursively hit.</span>
            <span class="n">hooks</span><span class="p">[</span><span class="n">module_ref</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">hooks</span><span class="p">[</span><span class="n">module_ref</span><span class="p">]</span>
            <span class="n">module_name</span> <span class="o">=</span> <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module_ref</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                <span class="n">module_ref</span> <span class="o">=</span> <span class="n">module_ref</span><span class="o">.</span><span class="n">get_original_module</span><span class="p">()</span>
            <span class="n">marker_layer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">CustomMarker</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="s1">&#39;True&#39;</span><span class="p">),</span>
                                           <span class="n">inputs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker_layer</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">module_to_name_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">hooks</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">inputs_hook</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_module_marker_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check to make sure all leaf modules have traced Custom Markers associated with them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_leaf_modules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_leaf_module_to_name_map</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">missing_inputs_entries</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">leaf_module</span> <span class="ow">in</span> <span class="n">all_leaf_modules</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leaf_module</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">missing_inputs_entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaf_module</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">missing_inputs_entries</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;In order to export a conditional model, all leaf modules need to be run with some input so &#39;</span>
                        <span class="s1">&#39;torch trace can be done.&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The following modules were not run during compute encodings:&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">missing_inputs_entries</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Please use the sim.run_modules_for_traced_custom_marker(&lt;module list&gt;, dummy_input) api to &#39;</span>
                        <span class="s1">&#39;pass dummy inputs to these modules.&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Modules which can take the same dummy input can be &#39;</span>
                        <span class="s1">&#39;grouped as a list. For groups of modules with different input shapes, please call &#39;</span>
                        <span class="s1">&#39;sim.run_modules_for_traced_custom_markers() for each group.&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exiting quantsim export early.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_export_conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                            <span class="n">forward_pass_callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">,</span>
                            <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">OnnxExportApiArgs</span><span class="p">(),</span>
                            <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export function for conditional models. Performs another round of forward passes to create and store traced</span>
<span class="sd">        CustomMarker info for each leaf module to be later used when scripting the model for export.</span>
<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph. It is required for the dummy_input to</span>
<span class="sd">                be placed on CPU.</span>
<span class="sd">        :param forward_pass_callback: A callback function that simply runs forward passes on the model. This callback</span>
<span class="sd">            function should use representative data for the forward pass, so the calculated encodings work for all</span>
<span class="sd">            data samples. This callback internally chooses the number of data samples it wants to use for calculating</span>
<span class="sd">            encodings. The callback should exercise all paths of the conditional model.</span>
<span class="sd">        :param forward_pass_callback_args: These argument(s) are passed to the forward_pass_callback as-is. Up to</span>
<span class="sd">            the user to determine the type of this parameter. E.g. could be simply an integer representing the number</span>
<span class="sd">            of data samples to use. Or could be a tuple of parameters or an object representing something more complex.</span>
<span class="sd">            If set to None, forward_pass_callback will be invoked with no parameters.</span>
<span class="sd">        :param onnx_export_args: onnx specific export arguments</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">onnx_export_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">onnx_export_args</span> <span class="o">=</span> <span class="n">OnnxExportApiArgs</span><span class="p">()</span>

        <span class="c1"># If model is conditional, we need to create traced CustomMarkers to be used later during export. Create hooks</span>
        <span class="c1"># here for creating a traced CustomMarker for each leaf module during the forward pass callback.</span>
        <span class="n">hooks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_inputs_hook</span><span class="p">(</span><span class="n">hooks</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">forward_pass_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">)</span>

        <span class="c1"># Any hooks that were hit during forward pass callback would have removed themselves. Remove the remaining</span>
        <span class="c1"># hooks that were not run.</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hooks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">h</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="c1"># Check that all paths were exercised</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_module_marker_map</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">configure_quantization_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                   <span class="n">default_data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantSimConfigurator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure inserted quantize ops using config file and fill in all the supported kernels</span>
<span class="sd">        :param config_file: Configuration file to use</span>
<span class="sd">        :param default_output_bw: default bitwidth for activations</span>
<span class="sd">        :param default_param_bw: default bitwidth for params</span>
<span class="sd">        :param default_data_type: default data type</span>
<span class="sd">        :return: QuantSimConfigurator object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;A connected graph failed to be built.</span><span class="se">\n</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;Unable to proceed with automatically configuring quantization ops using the config file.</span><span class="se">\n</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;Please configure quantization ops manually by redefining &#39;</span>
                         <span class="s1">&#39;QuantizationSimModel.configure_quantization_ops()&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">QuantSimConfigurator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="p">,</span> <span class="n">config_file</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">,</span>
                                    <span class="n">default_param_bw</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_and_freeze_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ignore_when_quantizer_disabled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Functionality to set encodings (both activation and parameter) as per the given encodings JSON file and</span>
<span class="sd">        freeze them.</span>
<span class="sd">        .. note:</span>
<span class="sd">            The encodings JSON file should be the {prefix}_torch.encodings json exported during sim.export()</span>

<span class="sd">        :param encoding_path: JSON file path from where to load the encodings.</span>
<span class="sd">        :param ignore_when_quantizer_disabled: ignore raising RuntimeError while setting encodings,</span>
<span class="sd">            when quantizers are disabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">encoding_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
            <span class="n">encodings_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_param_encodings</span><span class="p">(</span><span class="n">encodings_dict</span><span class="p">[</span><span class="s1">&#39;param_encodings&#39;</span><span class="p">],</span>
                                  <span class="n">freeze</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">ignore_when_quantizer_disabled</span><span class="o">=</span><span class="n">ignore_when_quantizer_disabled</span><span class="p">,</span>
                                  <span class="n">disable_quantizer_without_encoding</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_activation_encodings</span><span class="p">(</span><span class="n">encodings_dict</span><span class="p">[</span><span class="s1">&#39;activation_encodings&#39;</span><span class="p">],</span>
                                       <span class="n">freeze</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">ignore_when_quantizer_disabled</span><span class="o">=</span><span class="n">ignore_when_quantizer_disabled</span><span class="p">,</span>
                                       <span class="n">disable_quantizer_without_encoding</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_set_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">encoding_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                             <span class="n">freeze</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                             <span class="n">ignore_when_quantizer_disabled</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                             <span class="n">disable_quantizer_without_encoding</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quant_module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quant_module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                <span class="n">param_encoding</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">param_name</span><span class="p">:</span> <span class="n">encoding_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">quant_module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">encoding_dict</span>
                <span class="p">}</span>
                <span class="n">quant_module</span><span class="o">.</span><span class="n">import_param_encodings</span><span class="p">(</span><span class="n">param_encoding</span><span class="p">,</span>
                                                    <span class="n">freeze</span><span class="o">=</span><span class="n">freeze</span><span class="p">,</span>
                                                    <span class="n">ignore_when_quantizer_disabled</span><span class="o">=</span><span class="n">ignore_when_quantizer_disabled</span><span class="p">,</span>
                                                    <span class="n">disable_quantizer_without_encoding</span><span class="o">=</span><span class="n">disable_quantizer_without_encoding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_activation_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">activation_encoding_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                  <span class="n">freeze</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                  <span class="n">ignore_when_quantizer_disabled</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                  <span class="n">disable_quantizer_without_encoding</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">input_encoding</span> <span class="o">=</span> <span class="n">activation_encoding_dict</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">input_encoding</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">module</span><span class="o">.</span><span class="n">import_input_encodings</span><span class="p">(</span><span class="n">input_encoding</span><span class="p">,</span>
                                          <span class="n">freeze</span><span class="o">=</span><span class="n">freeze</span><span class="p">,</span>
                                          <span class="n">ignore_when_quantizer_disabled</span><span class="o">=</span><span class="n">ignore_when_quantizer_disabled</span><span class="p">,</span>
                                          <span class="n">disable_quantizer_without_encoding</span><span class="o">=</span><span class="n">disable_quantizer_without_encoding</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">output_encoding</span> <span class="o">=</span> <span class="n">activation_encoding_dict</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">output_encoding</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">module</span><span class="o">.</span><span class="n">import_output_encodings</span><span class="p">(</span><span class="n">output_encoding</span><span class="p">,</span>
                                           <span class="n">freeze</span><span class="o">=</span><span class="n">freeze</span><span class="p">,</span>
                                           <span class="n">ignore_when_quantizer_disabled</span><span class="o">=</span><span class="n">ignore_when_quantizer_disabled</span><span class="p">,</span>
                                           <span class="n">disable_quantizer_without_encoding</span><span class="o">=</span><span class="n">disable_quantizer_without_encoding</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_and_freeze_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">disable_quantizer_without_encoding</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set and freeze parameter encodings from encodings JSON file.</span>
<span class="sd">        .. note:</span>
<span class="sd">            The loaded json file should contain ONLY weight encodings. This is different from the json file used in</span>
<span class="sd">            `load_and_freeze_encodings`, which contains both weight and activation dictionaries.</span>

<span class="sd">        :param encoding_path: path from where to load parameter encodings file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load parameter encodings file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">encoding_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
            <span class="n">param_encodings</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;param_encodings&#39;</span> <span class="ow">in</span> <span class="n">param_encodings</span><span class="p">:</span>
                <span class="n">param_encodings</span> <span class="o">=</span> <span class="n">param_encodings</span><span class="p">[</span><span class="s1">&#39;param_encodings&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;An older AdaRound exported encoding file type has been detected! &quot;</span>
                               <span class="s2">&quot;Please regenerate it using the AdaRound export function from the latest &quot;</span>
                               <span class="s2">&quot;AIMET (version 1.32 or higher) if necessary. &quot;</span>
                               <span class="s2">&quot;Support for this encoding file will be deprecated in AIMET version 1.33.0.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_param_encodings</span><span class="p">(</span><span class="n">param_encodings</span><span class="p">,</span>
                                  <span class="n">freeze</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">ignore_when_quantizer_disabled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">disable_quantizer_without_encoding</span><span class="o">=</span><span class="n">disable_quantizer_without_encoding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">quant_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator for yielding all quantization wrappers and their names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">,</span> <span class="n">BaseQuantizationMixin</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span>

    <span class="k">def</span> <span class="nf">run_modules_for_traced_custom_marker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">],</span> <span class="n">dummy_input</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of modules to run and dummy input for the module, create a traced CustomMarker for each module</span>
<span class="sd">        and store it in the module_marker map. The same dummy input will be used for all modules.</span>

<span class="sd">        :param module_list: List of modules to create traced CustomMarkers for</span>
<span class="sd">        :param dummy_input: Dummy input for all modules</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">module_to_name_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_leaf_module_to_name_map</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">module_list</span><span class="p">:</span>
            <span class="c1"># Only perform init and trace if the given module is a leaf module, and we have not recorded it before</span>
            <span class="k">if</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">module_to_name_map</span> <span class="ow">and</span> <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">get_original_module</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">)</span> <span class="k">else</span> <span class="n">module</span>
                <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">module</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">marker_layer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">CustomMarker</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">dummy_input</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker_layer</span>

    <span class="k">def</span> <span class="nf">_validate_supported_kernels_for_quantizers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="n">SupportedKernelsAction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate supported kernels for all the Quantizers in the QuantSimModel</span>
<span class="sd">        :param action: The action to be performed when incorrect candidate is set in a quantizer</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">apply_act_param_rules</span><span class="p">(</span><span class="n">curr_candidate</span><span class="p">:</span> <span class="n">QuantDtypeBwInfo</span><span class="p">,</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QuantDtypeBwInfo</span><span class="p">],</span> <span class="n">module_name</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            helper function to validate both activation and param against the supported_kernels passed</span>
<span class="sd">            :param curr_candidate: candidate of interest</span>
<span class="sd">            :param allowed_supported_kernels: List of supported kernels for the given module</span>
<span class="sd">            :param module_name: name of the module</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">allow_error</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">curr_candidate</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">return</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">warn_on_error</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;candidate:</span><span class="si">%s</span><span class="s2"> is not under the supported_kernels for the module </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">curr_candidate</span><span class="p">,</span>
                                   <span class="n">module_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">assert_on_error</span><span class="p">:</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;candidate: </span><span class="si">{</span><span class="n">curr_candidate</span><span class="si">}</span><span class="s1"> is not under the supported_kernels for the module </span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">apply_act_rules</span><span class="p">(</span><span class="n">act</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">QuantizationDataType</span><span class="p">],</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QuantDtypeBwInfo</span><span class="p">],</span> <span class="n">module_name</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            helper function to validate both activation only against the supported_kernels passed</span>
<span class="sd">            :param act: act of the candidate to be validated</span>
<span class="sd">            :param allowed_supported_kernels: List of supported kernels for the given module</span>
<span class="sd">            :param module_name: name of the module</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">allow_error</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">is_same_activation</span><span class="p">(</span><span class="n">act</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">act</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">return</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">warn_on_error</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;activation:</span><span class="si">%s</span><span class="s2"> is not under the supported_kernels for the module </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span> <span class="n">module_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">assert_on_error</span><span class="p">:</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;activation: </span><span class="si">{</span><span class="n">act</span><span class="si">}</span><span class="s1"> is not under the supported_kernels for the module </span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

        <span class="c1"># retrieve all the act and param quantizer candidates, and validate them against supported_kernels</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">LazyQuantizeWrapper</span><span class="p">))</span> <span class="ow">and</span> <span class="n">module</span><span class="o">.</span><span class="n">supported_kernels</span><span class="p">:</span>
                <span class="n">supported_kernels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">supported_kernel</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">supported_kernels</span><span class="p">:</span>
                    <span class="c1"># ((activation bitwidth, activation data type), (param bitwidth, param data type))</span>
                    <span class="c1"># TODO modify this once reformat_supported_kernels generates of type QuantDtypeBwInfo</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="n">supported_kernels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">QuantDtypeBwInfo</span><span class="p">(</span><span class="n">supported_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">supported_kernels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">QuantDtypeBwInfo</span><span class="p">(</span><span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">act_candidates</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">param_candidate</span> <span class="o">=</span> <span class="p">()</span>
                <span class="k">for</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">input_quantizers</span> <span class="o">+</span> <span class="n">module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">:</span>
                    <span class="n">act_candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">quantizer</span><span class="o">.</span><span class="n">bitwidth</span><span class="p">,</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">data_type</span><span class="p">))</span>

                <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                    <span class="n">param_candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bitwidth</span><span class="p">,</span>
                                       <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">param_candidate</span><span class="p">:</span>
                    <span class="c1"># we need to check weights against all the activations</span>
                    <span class="k">for</span> <span class="n">act_candidate</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">act_candidates</span><span class="p">):</span>
                        <span class="n">apply_act_param_rules</span><span class="p">(</span><span class="n">QuantDtypeBwInfo</span><span class="p">(</span><span class="n">act_candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">act_candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param_candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                               <span class="n">param_candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">supported_kernels</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">act_candidates</span><span class="p">):</span>
                        <span class="n">apply_act_rules</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">supported_kernels</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_replace_quantization_wrapper_with_native_torch_quantization_nodes</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively remove quantization wrappers from all appropriate modules starting with a given module</span>
<span class="sd">        :param quant_sim_model: model for which QcQuantizeWrapper gets replaced with wrapped module using</span>
<span class="sd">        native torch quantization nodes</span>
<span class="sd">        :param device: device on which model is present</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Recursively replace quantization wrappers to native torch quantization nodes</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
            <span class="c1"># Create a native torch quantization node</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
                <span class="n">embedded_module</span> <span class="o">=</span> <span class="n">NativeTorchQuantWrapper</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="s1">&#39;_module_to_wrap&#39;</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">embedded_module</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Do not support save model embedded native torch quantization nodes using QcQuantizeRecurrent.&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span>

            <span class="c1"># Recursively call children modules if present</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_replace_quantization_wrapper_with_native_torch_quantization_nodes</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">save_model_with_embedded_quantization_nodes</span><span class="p">(</span><span class="n">sim_model</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                                                    <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                    <span class="n">export_to_torchscript</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">is_conditional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export model embedded with native torch quantization nodes. These nodes will be exported</span>
<span class="sd">        as default onnx or torch script quantized nodes.</span>
<span class="sd">        :param sim_model: model with the quantsim wrappers</span>
<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph</span>
<span class="sd">        :param onnx_export_args: optional export argument with onnx specific overrides if not provide export via</span>
<span class="sd">                torchscript graph. Int16 can only be exported by torchscript</span>
<span class="sd">        :param export_to_torchscript: If True, export to torchscript. Export to onnx otherwise. Defaults to False.</span>
<span class="sd">        :param is_conditional: True if model is conditional, False otherwise</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_validate_torchquantizer</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">):</span>
            <span class="c1"># To avoid non 8 bit TorchQuantizer are exported to ONNX</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">NativeTorchQuantWrapper</span><span class="p">):</span>
                    <span class="n">quantizers</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">input_quantizers</span> <span class="o">+</span> <span class="n">module</span><span class="o">.</span><span class="n">output_quantizers</span>
                    <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                        <span class="n">quantizers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="s1">&#39;bias&#39;</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                        <span class="n">quantizers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">]]</span>

                    <span class="k">for</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">quantizers</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only 8 bit quantizers are supported by exporting to ONNX model.&#39;</span>
                                             <span class="s1">&#39;Please enable export_to_torchscript if you want to export non 8 bit quantizers.&#39;</span><span class="p">)</span>

        <span class="n">model_filename</span> <span class="o">=</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;_embedded&#39;</span> <span class="o">+</span> <span class="s1">&#39;.onnx&#39;</span>
        <span class="n">model_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">model_filename</span><span class="p">)</span>
        <span class="n">quant_sim_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sim_model</span><span class="p">)</span>

        <span class="n">device</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dummy_input</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">dummy_input</span> <span class="o">=</span> <span class="n">dummy_input</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dummy_input</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">input</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">dummy_input</span><span class="p">])</span>  <span class="c1"># pylint: disable=consider-using-generator</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_replace_quantization_wrapper_with_native_torch_quantization_nodes</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">export_to_torchscript</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>
                <span class="n">ts_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;_embedded&#39;</span> <span class="o">+</span> <span class="s1">&#39;.torchscript.pth&#39;</span><span class="p">)</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">ts_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_validate_torchquantizer</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">)</span>
            <span class="n">OnnxSaver</span><span class="o">.</span><span class="n">_export_model_to_onnx</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span> <span class="n">model_path</span><span class="p">,</span> <span class="n">is_conditional</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">)</span> <span class="c1"># pylint: disable=protected-access</span>

    <span class="k">def</span> <span class="nf">_enable_output_quantizers_for_specific_cast_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inout_tensors_dtypes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable output quantizer for Cast Ops where datatype of input tensor is int/bool</span>
<span class="sd">        and data type of output tensor is float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">model_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="o">.</span><span class="n">_model_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
        <span class="n">torch_int_dtypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">torch</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">}</span>
        <span class="n">torch_float_dtypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">torch</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">module</span><span class="p">,</span> <span class="n">inout_dtypes</span> <span class="ow">in</span> <span class="n">inout_tensors_dtypes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">input_tensor_dtype</span> <span class="o">=</span> <span class="n">inout_dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">output_tensor_dtype</span> <span class="o">=</span> <span class="n">inout_dtypes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># pylint: disable=protected-access</span>
            <span class="n">module_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="o">.</span><span class="n">_module_to_name</span><span class="p">[</span><span class="n">module</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">model_prefix</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">input_tensor_dtype</span> <span class="o">!=</span> <span class="n">output_tensor_dtype</span> <span class="ow">and</span> <span class="n">input_tensor_dtype</span> <span class="ow">in</span> <span class="n">torch_int_dtypes</span> <span class="ow">and</span> <span class="n">output_tensor_dtype</span> <span class="ow">in</span> <span class="n">torch_float_dtypes</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Enabling output quantizer for module </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">module_name</span><span class="p">)</span>
                <span class="n">wrapped_module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">module_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">output_quantizer</span> <span class="ow">in</span> <span class="n">wrapped_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">output_quantizer</span><span class="p">,</span> <span class="s1">&#39;enabled&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">save_checkpoint</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">:</span> <span class="n">QuantizationSimModel</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This API provides a way for the user to save a checkpoint of the quantized model which can</span>
<span class="sd">    be loaded at a later point to continue fine-tuning e.g.</span>
<span class="sd">    See also load_checkpoint()</span>

<span class="sd">    :param quant_sim_model: QuantizationSimModel to save checkpoint for</span>
<span class="sd">    :param file_path: Path to the file where you want to save the checkpoint</span>
<span class="sd">    :return: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load_checkpoint</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantizationSimModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the quantized model</span>

<span class="sd">    :param file_path: Path to the file where you want to save the checkpoint</span>
<span class="sd">    :return: A new instance of the QuantizationSimModel created after loading the checkpoint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sim</span>


<span class="k">def</span> <span class="nf">check_accumulator_overflow</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">quant_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">accum_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks for any potential for accumulator overflow across all the layers of the given model</span>
<span class="sd">    :param model: Model</span>
<span class="sd">    :param quant_bw: Bitwidth the layers are quantized at</span>
<span class="sd">    :param accum_bw: Bitwidth of the accumulator</span>
<span class="sd">    :return: Name of the layer with the most accumulator range used and range used</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">most_accum_range_used</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">most_accum_range_used_layer</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">):</span>
            <span class="n">was_accum_range_exceeded</span><span class="p">,</span> <span class="n">accum_range_used</span> <span class="o">=</span> <span class="n">get_conv_accum_bounds</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                                                                               <span class="n">quant_bw</span><span class="p">,</span> <span class="n">accum_bw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">accum_range_used</span> <span class="o">&gt;</span> <span class="n">most_accum_range_used</span><span class="p">:</span>
                <span class="n">most_accum_range_used</span> <span class="o">=</span> <span class="n">accum_range_used</span>
                <span class="n">most_accum_range_used_layer</span> <span class="o">=</span> <span class="n">layer_name</span>

            <span class="k">if</span> <span class="n">was_accum_range_exceeded</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Possible accumulator overflow for layer: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">most_accum_range_used</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No overflow detected. Layer </span><span class="si">%s</span><span class="s1"> had the most accumulator range used: </span><span class="si">%f%%</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">most_accum_range_used_layer</span><span class="p">,</span> <span class="n">most_accum_range_used</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Overflow detected. Layer </span><span class="si">%s</span><span class="s1"> had the most accumulator range used: </span><span class="si">%f%%</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">most_accum_range_used_layer</span><span class="p">,</span> <span class="n">most_accum_range_used</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">most_accum_range_used_layer</span><span class="p">,</span> <span class="n">most_accum_range_used</span>


<span class="k">def</span> <span class="nf">load_encodings_to_sim</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">:</span> <span class="n">QuantizationSimModel</span><span class="p">,</span> <span class="n">pytorch_encoding_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads the saved encodings to quant sim model. The encoding filename to load should end in _torch.encodings,</span>
<span class="sd">    generated as part of quantsim export.</span>

<span class="sd">    :param quant_sim_model: Quantized model to load encodings for. Note: The model configuration should be the same as</span>
<span class="sd">        when encodings were exported.</span>
<span class="sd">    :param pytorch_encoding_path: Path of the encodings file to load.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=too-many-locals, too-many-branches</span>
    <span class="c1"># Load encodings file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pytorch_encoding_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
        <span class="n">encodings</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>

    <span class="n">param_encodings</span> <span class="o">=</span> <span class="n">encodings</span><span class="p">[</span><span class="s1">&#39;param_encodings&#39;</span><span class="p">]</span>
    <span class="n">activation_encodings</span> <span class="o">=</span> <span class="n">encodings</span><span class="p">[</span><span class="s1">&#39;activation_encodings&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
            <span class="n">module</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">)</span>

        <span class="n">param_encoding</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">param_name</span><span class="p">:</span> <span class="n">param_encodings</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">param_encodings</span>
        <span class="p">}</span>
        <span class="n">module</span><span class="o">.</span><span class="n">import_param_encodings</span><span class="p">(</span><span class="n">param_encoding</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">input_encoding</span> <span class="o">=</span> <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">input_encoding</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">module</span><span class="o">.</span><span class="n">import_input_encodings</span><span class="p">(</span><span class="n">input_encoding</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">output_encoding</span> <span class="o">=</span> <span class="n">activation_encodings</span><span class="p">[</span><span class="n">module_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">output_encoding</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">module</span><span class="o">.</span><span class="n">import_output_encodings</span><span class="p">(</span><span class="n">output_encoding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_enabled</span><span class="p">(</span><span class="n">quantizer</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">quantizer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">quantizer</span><span class="p">,</span> <span class="s1">&#39;enabled&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">is_initialized</span><span class="p">(</span><span class="n">quantizer</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">quantizer</span><span class="p">,</span> <span class="s1">&#39;is_initialized&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">is_initialized</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">quant_wrappers</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
            <span class="n">input_quantizers</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span>
            <span class="n">output_quantizers</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">output_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_quantizers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_enabled</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_initialized</span><span class="p">(</span><span class="n">quantizer</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No encoding loaded for input quantizer </span><span class="si">%s</span><span class="s1"> of layer </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">is_enabled</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_initialized</span><span class="p">(</span><span class="n">quantizer</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No encoding loaded for param quantizer </span><span class="si">%s</span><span class="s1"> of layer </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_quantizers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_enabled</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_initialized</span><span class="p">(</span><span class="n">quantizer</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No encoding loaded for output quantizer </span><span class="si">%s</span><span class="s1"> of layer </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">QuantizationSimModel</span><span class="p">):</span>
        <span class="c1"># Only for V1 quantsim</span>
        <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">replace_wrappers_for_quantize_dequantize</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">has_valid_encodings</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">:</span> <span class="n">ExportableQuantModule</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility for determining whether a given qc_quantize_op has any valid encodings.</span>

<span class="sd">    :param qc_quantize_op: Qc quantize op to evaluate</span>
<span class="sd">    :return: True if any input, param, or output quantizers have valid encodings, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">,</span> <span class="p">(</span><span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">)):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;has_valid_encodings only supported for QcQuantizeWrapper and QcQuantizeRecurrent &quot;</span>
                     <span class="s2">&quot;modules&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">,</span> <span class="p">(</span><span class="n">ExportableQuantModule</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">,</span> <span class="n">ExportableQuantModule</span><span class="p">):</span>
        <span class="n">all_encodings</span> <span class="o">=</span> <span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">export_output_encodings</span><span class="p">()</span> <span class="o">+</span> <span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">export_input_encodings</span><span class="p">()</span> <span class="o">+</span> \
                        <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">export_param_encodings</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">all_encodings</span><span class="p">])</span>  <span class="c1"># pylint: disable=consider-using-generator,use-a-generator</span>
    <span class="n">input_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">output_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">input_quantizers</span> <span class="o">+</span> <span class="n">output_quantizers</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> <span class="p">(</span><span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">data_type</span> <span class="ow">is</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">compute_encodings_for_sims</span><span class="p">(</span><span class="n">sim_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QuantizationSimModel</span><span class="p">],</span> <span class="n">forward_pass_callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                               <span class="n">forward_pass_callback_args</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute encodings for a list of QuantSims.</span>

<span class="sd">    :param sim_list: List of QuantSims to compute encodings for.</span>
<span class="sd">    :param forward_pass_callback: A callback function that simply runs forward passes on the models. This callback</span>
<span class="sd">        function should use representative data for the forward pass, so the calculated encodings work for all</span>
<span class="sd">        data samples. This callback internally chooses the number of data samples it wants to use for calculating</span>
<span class="sd">        encodings.</span>
<span class="sd">        The callback expects exactly two inputs:</span>
<span class="sd">            - List of models which are involved in the forward pass. The models are taken directly from calling</span>
<span class="sd">            sim.model for each sim in sim_list, passed in the same order in which the sims appear in sim_list.</span>
<span class="sd">            - Forward pass callback args</span>
<span class="sd">    :param forward_pass_callback_args: These argument(s) are passed to the forward_pass_callback as-is. Up to</span>
<span class="sd">        the user to determine the type of this parameter. E.g. could be simply an integer representing the number</span>
<span class="sd">        of data samples to use. Or could be a tuple of parameters or an object representing something more complex.</span>
<span class="sd">        If set to None, forward_pass_callback will be invoked with no parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx_managers</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">sim_list</span><span class="p">:</span>
        <span class="n">ctx_managers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">model</span><span class="p">))</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">prepare_sim_for_compute_encodings</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">mgr</span> <span class="ow">in</span> <span class="n">ctx_managers</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">forward_pass_callback</span><span class="p">([</span><span class="n">sim</span><span class="o">.</span><span class="n">model</span> <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">sim_list</span><span class="p">],</span> <span class="n">forward_pass_callback_args</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">sim_list</span><span class="p">:</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">compute_layer_encodings_for_sim</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Qualcomm Innovation Center, Inc..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>